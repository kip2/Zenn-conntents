{
  "title": "Clojureキャッチアップの旅",
  "closed": false,
  "archived": false,
  "created_at": "2024-10-25",
  "comments": [
    {
      "author": "kip2",
      "created_at": "2024-10-25",
      "body_markdown": "# 記事で気になっているもの\n\nhttps://qiita.com/223kazuki/items/23e480880698becdbeff\n\nhttps://zenn.dev/uochan/articles/2020-12-09-clj-kondo-hooks\n\nhttps://zenn.dev/uochan/articles/2022-05-26-build-edn\n\nhttps://zenn.dev/kj455/articles/dfa23c8357b274\n\nhttps://qiita.com/dexia/items/d3e8a7593f8c105f5124\n\nhttps://howitworks.hatenablog.jp/entry/2018/04/21/111137\n\nゼロからClojure入門した振り返り\nhttps://qiita.com/Saibaba81/items/16ef2486d2345f7f0e57\n\n関連リンク集\nhttps://qiita.com/lagenorhynque/items/68c314c288b75a9492ba\n\nClojureによるWeb開発\nhttps://ayato-p.github.io/clojure-beginner/intro_web_development/index.html\n\nhttps://note.com/aki_takeuchi/n/n8ebd49cb677a\n\nhttps://www.kbaba1001.com/posts/202408021559_the-clojure-workshop/\n\nhttps://github.com/athos/japanese-clojure-companies\n\nhttps://zenn.dev/huuya/articles/601699ee8a5bc7\n\nhttps://zenn.dev/neco8225/articles/5c233c5b7688ee\n\nhttps://scrapbox.io/lagenorhynque/Clojure%E3%81%AB%E5%85%A5%E9%96%80%E3%81%97%E3%81%9F%E3%82%89%E7%9F%A5%E3%81%A3%E3%81%A6%E3%81%8A%E3%81%8D%E3%81%9F%E3%81%84N%E5%80%8B%E3%81%AE%E3%81%93%E3%81%A8\n\nhttps://blog.totakke.net/posts/2016-06-29-lazy-seq-loop/\n\nhttps://qiita.com/miyabisun/items/5dc3b8a5d42a8eae84d5\n\nhttps://qiita.com/tetsutakamurata76/items/1da929606f36c6466e11\n\nhttps://tnoda-clojure.tumblr.com/post/128047865422/java-collection-interop\n\n## 末尾再帰最適化\n\nhttps://qiita.com/takl/items/6d3319e835a27fc5e4b9\n\nhttps://qiita.com/pebblip/items/cf8d3230969b2f6b3132\n\n## マクロ\n\nhttps://qiita.com/BooookStore/items/e7919d7c2504bc7a5f2b\n\nhttps://qiita.com/lagenorhynque/items/41b8ea18ccaee8a0a5db\n\n## オブジェクト指向\n\nhttps://qiita.com/yosgspec/items/25d392c47b883480e09d\n\n## アルゴリズム\n\nクイックソート\nhttps://eddmann.com/posts/quicksort-in-clojure/\n\n# ライブラリなどに関して気になるもの\n型validate\nhttps://zenn.dev/uochan/articles/2020-12-25-malli-clj-kondo\n\n文字列操作\nhttps://zenn.dev/hatappo/articles/9007316cee7867\n\n",
      "body_updated_at": "2024-11-02"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-25",
      "body_markdown": "# 目的\n\nClojure使いこなしたいのでキャッチアップをする。\n\n気ままに行う予定なので、雑多な内容になると思われます。",
      "body_updated_at": "2024-10-26"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-25",
      "body_markdown": "# 書籍\nキャッチアップするにあたって買った本を虫干し。\n\n## 関数型デザイン\n偉大なるアンクル・ボブの書いた本。\nClojureを使って、OOPと関数型の対比を行うことによって関数型を学ぶ本。\nだと思う。まだ読み始めたばかり。\nhttps://www.kadokawa.co.jp/product/302404003071/\n\n## プログラミングClojure 第2版\nClojureの解説本。\nおそらく日本語で詳しいのはこの本だけ？\n翻訳は、Gauche Schemeの作者であり、Lisp界隈に名のしれた川合四郎さん。\n聖典、Land of Lispの翻訳者でもある。\nつまり、この本も実質聖典。\nまだ読み始めたばかり。\nhttps://www.ohmsha.co.jp/book/9784274069130/\n追記：第2版はversion1.3の解説らしい。\n第3版は1.9に対応しているらしいが、翻訳は出てない。\nhttps://pragprog.com/titles/shcloj3/programming-clojure-third-edition/\n1.3から1.9への変更点を書いた記事があったのでこれでお茶を濁そうかな。\nhttps://scrapbox.io/ayato-p/%E5%AD%94%E9%9B%80%E6%9C%AC%E3%81%A7%E6%83%85%E5%A0%B1%E3%81%8C%E6%AD%A2%E3%81%BE%E3%81%A3%E3%81%A6%E3%81%84%E3%82%8B%E4%BA%BA%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3%E3%82%A2%E3%83%83%E3%83%97%E6%83%85%E5%A0%B1%E3%81%BE%E3%81%A8%E3%82%81\n\n## おいしいClojure入門\n\nCojureでいろいろなことができることを示したある種のレシピ本。\nいろいろなライブラリを使用して、いろいろなことを実現しているから眺めているだけでも楽しい。\nまだ読み始めたばかり。\nhttps://gihyo.jp/book/2013/978-4-7741-5991-1\n\n## 7つの言語7つの世界\n\nパラダイムの違う7つの言語を見ることで、プログラミングの奥深い世界を知る本。\n「Clojureの解説もあるし、他の言語との対比も書かれてるかなー？」と思って購入。\nまだ読み始めたばかり。\nhttps://amzn.asia/d/4dITn0L\n\n## データ指向プログラミング\n\nデータ指向プログラミングの解説本。\nClojureが話に出てきた覚えがあるので、ここに挙げた。\n読みさして止まっているので、この気に読み込んでいきたい。\nhttps://www.shoeisha.co.jp/book/detail/9784798179797",
      "body_updated_at": "2024-10-27"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-25",
      "body_markdown": "# Kindle本\nKindleで出ていて気になった電子書籍の虫干し。\nまだ購入していない。\n\nhttps://amzn.asia/d/1Bnn5o2\n\nhttps://amzn.asia/d/1VZ5DXm\n\nhttps://amzn.asia/d/5aIJVPI\n\nhttps://amzn.asia/d/7CBQNf9"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-25",
      "body_markdown": "# 動画\n\nClojureに関する動画がまとまっているチャンネル。\nまだ見ていないが、Clojure作者のRich Hickeyさんによる講演動画もあるっぽい。\nhttps://www.youtube.com/@ClojureTV\n\n## 自分をClojure化する方法\n\nClojureのイントロダクション動画。\nClojureの魅力を楽しく解説している動画。\nなお、「タイトルは釣りです」とのこと。\n2010年の動画だが、色褪せない魅力があると思う。\nhttps://youtu.be/OqIjENKRydc?si=uVxY7FOqTpeoDV4J\n\n## Clojureによるバイトコードプログラミング\n\n発表者自作のインラインアセンブラマクロであるiasmの話。\nまだインラインアセンブラマクロがどのようなものか理解していないが、挑戦として面白いと思う。\nhttps://youtu.be/OXBlKUpM_Bs?si=vkmBOxVtwnE1OVOW\n\n## 気になっているもの\n\nまだ見ていないものをメモとして。\n見たら、順次簡単な解説を書こうと思う。\n\nhttps://www.youtube.com/watch?v=PueDZWlwo3U\n\nhttps://www.youtube.com/watch?v=eveoq3nSOeg\n",
      "body_updated_at": "2024-10-27"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-25",
      "body_markdown": "# Leiningenを使ってHello world\nLeiningenを使ってHello worldを行う。\nLeiningenはデファクトスタンダードのプロジェクト管理ツールらしい。\n\nプロジェクト作成したら基本的なものを作成してくれる。\n\n```sh\nlein new app hello-clojure\n```\n\nディレクトリを移動して実行してみよう。\n\n```sh\ncd hello-clojure\nlein run\n# Hello, World!と表示される。\n```\n\n## プロジェクトのディレクトリ構成\n\nLeiningenを使って、デフォルトで作成されるのディレクトリ構成。\n\n```sh\n.\n├── CHANGELOG.md\n├── LICENSE\n├── README.md\n├── doc\n│   └── intro.md\n├── project.clj\n├── resources\n├── src\n│   └── hello_clojure\n│       └── core.clj\n├── target\n│   ├── classes\n│   │   └── META-INF\n│   │       └── maven\n│   │           └── hello-clojure\n│   │               └── hello-clojure\n│   │                   └── pom.properties\n│   └── stale\n│       └── leiningen.core.classpath.extract-native-dependencies\n└── test\n    └── hello_clojure\n        └── core_test.clj\n\n14 directories, 9 files\n```\n\n## 本体のコード\n\nHello worldを出力してくれるが、どのような関数となっているのか。\n`hello-clojure/src/hello_clojure/core.clj`の中身を見てみる。\n\n```clojure\n(ns hello-clojure.core\n  (:gen-class))\n\n(defn -main\n  \"I don't do a whole lot ... yet.\"\n  [& args]\n  (println \"Hello, World!\"))\n```\n\nよくわからないので、ChatGPTに聞いてみる。\n\n:::message\nこちらのコードは、Clojureで「Hello, World!」を出力するシンプルなプログラムです。一行ずつ説明しますね。\n\n```clojure\n(ns hello-clojure.core\n  (:gen-class))\n```\n\n1. **`(ns hello-clojure.core`**  \n   - `ns`は名前空間（namespace）を定義するマクロで、このプログラム内のコードの「名前空間」を指定します。名前空間は、コードをグループ化し、他の名前空間と区別するために使われます。\n   - `hello-clojure.core`はこのプログラムの名前空間名で、「hello-clojure」というプロジェクトの「core」部分を意味しています。\n\n2. **`(:gen-class)`**  \n   - `:gen-class`はClojureの`gen-class`指示子で、JavaのクラスとしてClojureコードを生成できるようにするためのオプションです。\n   - このオプションを使うことで、ClojureコードをJavaから直接呼び出したり、実行可能なクラスファイルとしてパッケージ化することができます。`gen-class`を使うと、Javaの`main`メソッド相当の`-main`関数を定義でき、Java実行環境からこのプログラムを実行できるようになります。\n\n---\n\n```clojure\n(defn -main\n  \"I don't do a whole lot ... yet.\"\n  [& args]\n  (println \"Hello, World!\"))\n```\n\n3. **`(defn -main`**  \n   - `defn`は関数を定義するためのマクロです。`-main`は関数の名前で、Javaの`main`メソッドに相当する「エントリポイント」として使われます。\n   - `-main`関数を定義することで、このプログラムを実行すると、`-main`関数が最初に呼び出されます。\n\n4. **`\"I don't do a whole lot ... yet.\"`**  \n   - これは`-main`関数の「ドキュメント文字列」です。関数の説明を文字列として記述しておくと、後でドキュメントツールやREPLで関数の情報を参照する際に役立ちます。\n   - この例では、「まだ特に何もしないよ」という説明が書かれていますが、実行には影響しません。\n\n5. **`[& args]`**  \n   - `& args`は可変長引数を受け取るための引数リストです。`args`はリストとしてまとめられ、`-main`関数に引数が指定された場合、その引数が`args`に含まれます。\n   - ここでは引数は特に使用されていませんが、必要に応じてアクセスできます。\n\n6. **`(println \"Hello, World!\")`**  \n   - `println`は標準出力に文字列を出力し、改行を追加します。この行は「Hello, World!」という文字列を表示するコードです。\n   - `-main`関数が実行されると、`Hello, World!`が画面に表示されます。\n\n### まとめると\n\nこのプログラムはClojureプロジェクトの名前空間`hello-clojure.core`を定義し、`-main`というエントリポイント関数で「Hello, World!」を出力しています。\n:::",
      "body_updated_at": "2024-10-25"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-25",
      "body_markdown": "# VSCodeにいれたプラグイン\n\nVSCodeを主に使用しているので、プラグインを入れていく。\n何をいれるかもわかってないので、とりあえず動かしてみて、入れ替わり立ち替わりしてみる。\n\nCalva\nhttps://github.com/BetterThanTomorrow/calva\n\nsnippets\nhttps://github.com/Leocardoso94/clojure-snippets\n\nLinter\nhttps://github.com/marcomorain/clojure-lint",
      "body_updated_at": "2024-10-26"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-26",
      "body_markdown": "# Calvaの使い方についての調査\n\nCalvaの使い方のイメージが沸かなかったので、以下の動画を視聴。\n\nhttps://youtu.be/6uUynWkMDGM?si=KL6NGp6m65ATeY1y\n\nCalvaを使うとREPLサーバーが立ち上がり、ファイルに書き込んだ内容を実行することが可能らしい。\nつまり、\n\n- ファイルへのコードの書き込み\n- 書いたコードをREPLみたいに、その場で実行して確かめることができる\n\nという、REPLとファイルにコードを書くことのいいとこどりのような形式で使えるらしい。\nなにそれ最強じゃんね。",
      "body_updated_at": "2024-10-26"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-26",
      "body_markdown": "# CalvaTVチャンネル\n\n探してる途中で見つけたので、メモとして記載。\nhttps://www.youtube.com/@CalvaTV\n\n\n"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-26",
      "body_markdown": "\n# Calvaを使ってみる\n\nCalvaを使って簡単なコードを書いてみるテスト。\n\n## 起動の仕方\n\nまずはREPLサーバーの起動の仕方。\n\nコマンドパレットを開き、`Calva: Start a Project REPL and Connect`を選択。\n![](https://storage.googleapis.com/zenn-user-upload/f40bee4db771-20241026.png)\n\nREPLを実行したいディレクトリを選択する。\n今回は`Practice-Clojure/hello-clojure`が該当。\n![](https://storage.googleapis.com/zenn-user-upload/6b4344f9cd9a-20241026.png)\n\nProjectのTypeを選択する。\nよくわかっていないが、Leiningenを導入しているのでそれを選択。\n![](https://storage.googleapis.com/zenn-user-upload/b254f9f473c4-20241026.png)\n\nすると、REPLが起動する。\n![](https://storage.googleapis.com/zenn-user-upload/a417e5f404c8-20241026.png)\n起動したREPLのファイルは特にいじらないでOK。\n\nあとは、コードを書く方のcljファイルにコードを書いていけば良い。\n\n## 実行の仕方\n\nコードを書いた行の末尾で、`Cmd + Enter`(Mac)あるいは`Ctrl + Enter`(Windows)を入力すれば実行できる。\n\n試しに実行している様子。\n![](https://storage.googleapis.com/zenn-user-upload/82564d91571d-20241026.png)\n\nなお、行の中間などで実行した場合は、シンタックスエラーが出るようだ。\nカーソルの位置が重要みたい。\n\n`Hello, `のスペースのあたりで実行した場合こうなった。\n![](https://storage.googleapis.com/zenn-user-upload/52eec0cb6225-20241026.png)\n\n## 終了の仕方\n\nREPLサーバーを終了させる方法。\n\nコマンドパレットを開き、`Calva: Disconnect from the REPL Server`を選択する。\n![](https://storage.googleapis.com/zenn-user-upload/aff2615f1035-20241026.png)\n\n",
      "body_updated_at": "2024-10-26"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-26",
      "body_markdown": "# fizzbuzzを書いてみる\n\nとりあえずAIに聞きながらfizzbuzzを書いてみる。\n\n```clojure\n\n(defn fizzbuzz [n]\n  (cond\n    (and (zero? (mod n 3)) (zero? (mod n 5))) \"FizzBuzz\"\n    (zero? (mod n 3)) \"Fizz\"\n    (zero? (mod n 5)) \"Buzz\"\n    :else (str n)))\n\n(doseq [i (range 20)]\n  (println (fizzbuzz i)))\n```\n\nClojureでは副作用が無いコードが推奨されるらしいので、その形で書いた。\n\n副作用のない形で関数を書くのは馴染がないため、今度も注意して実装していきたい。\n",
      "body_updated_at": "2024-10-26"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-26",
      "body_markdown": "# Calvaの開発体験\n\n開発体験かなりいい。\n何がいいかというと、「本番用のファイルに実験コードを書いて実行できる」ということ。\n\nCalvaでは、コードを書いて、その場で実行ができる。\nつまり、REPLでコードを実行するのと体験が変わらない。\n\nしかも、その書いたコードはファイルに残る。\nつまり、REPLで実行することとファイルにコードを書くことを、両立して行える。\n\n具体的に何が嬉しいかというのを一つのケースで示す。\n\n1.   開発中に、いままで使ったことの無い関数を使う必要が出てきた。\n2.   関数の動きを確かめるコードを書いて、関数の使い方を学ぶ。\n3.   使い方がわかった関数で、必要なコードを書く。\n\nという流れになると思うが、従来、自分は以下のように行っていた。\n\n- 別ファイルや実験用のプロジェクトを作成し、動きを確かめるコードをそこに書いて確かめる。\n- 本番用のファイルに、必要なコードを書く。\n\nという感じで、ファイルを行きつ戻りつしており、集中が途切れること甚だしかった（ワーキングメモリーが小さいのでわりと困っていた）。\n\nCalvaを使うと、同じファイル内で完結できる。\n\n- 同じファイルに実験用のコードを書いて動きを確かめる。\n- 本番用のコードを、そのまま同じファイルに書く。\n- 不必要になった実験用のコードを削除する。\n\nこれはかなりいい。\n自分が探してきた理想の開発方法かもしれない。\n\n## 追記\n\nこんな記事を見つけた。\nhttps://zenn.dev/nfunato/articles/jp-on-repl-programming\n\nClojureでの開発方法はREPL駆動開発というらしい。\nCalvaでやってることが、その考え方の一つの実装と言えるのかも。",
      "body_updated_at": "2024-10-26"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-27",
      "body_markdown": "# テストの方法\n\nテストのやり方を書く。\n\n## テストコードを書く\n\nテストコードを書く。\n`test`ディレクトリの中にあるファイルに記載する。\n今回で言えば、以下のディレクトリにある`core_test.clj`に記載する。\n\n```sh\n# ディレクトリは一部のみ抜粋しているので、実際のディレクトリ構成とは異なることに注意\n├── src\n│   └── hello_clojure\n│       └── core.clj\n└── test\n    └── hello_clojure\n        └── core_test.clj\n```\n\n今回はfizzbuzz関数のテストコードを書いている。\n\n```clojure\n(ns hello-clojure.core-test\n  (:require [clojure.test :refer :all]\n            [hello-clojure.core :refer :all]))\n\n(deftest fizzbuzz-test\n  (testing \"FizzBuzzの動作\")\n  (is (= \"Fizz\" (fizzbuzz 3)))\n  (is (= \"Buzz\" (fizzbuzz 5)))\n  (is (= \"FizzBuzz\" (fizzbuzz 15)))\n  (is (= \"2\" (fizzbuzz 2))))\n```\n\n## CalvaのREPLにロードする\n\n書いたテストファイルをREPL上にロードする必要がある。\n\nショートカットキーでも可能らしいが、vimキーバインドと競合していたため、コマンドパレットを用いた方法で実行してみる。\n\nコマンドパレットを開き、`Calva: Load/Evaluage Current File and its Requires/Dependencies`を選択する(画像は表示の関係上見切れている）。\n![](https://storage.googleapis.com/zenn-user-upload/ebfa3cbe78ac-20241027.png)\n\nREPL側で読み込まれていることが確認できれば成功。\n![](https://storage.googleapis.com/zenn-user-upload/0ef3b8dd4b3c-20241027.png)\n\n## テストの実行\n\nコマンドパレットを開き、`Calva: Run Current Test`を選択。\n![](https://storage.googleapis.com/zenn-user-upload/a89d7c827691-20241027.png)\n\nREPLでテストが実行されていることを確認する。\n![](https://storage.googleapis.com/zenn-user-upload/d996d7e0c5ea-20241027.png)\n\n## 追記補足\n\n設定をいじったら、クリックだけで実行できるようになったので、メモ。\n\nVSCodeの以下の項目にチェックを入れる。\n![](https://storage.googleapis.com/zenn-user-upload/9c7760e2a10c-20241103.png)\n\nすると、他の言語ではおなじみの、テスト実行ボタンが出現する。\n![](https://storage.googleapis.com/zenn-user-upload/8187be29d02b-20241103.png)\n\n注意点として、core.cljの実行しか成功しなかったこと（同じネームスペース内にテスト対象の関数とテストコードが併存している必要がある？）。\n\ncore_test.cljでの実行が失敗しているので、これについては今後の課題。\n\n",
      "body_updated_at": "2024-11-03"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-27",
      "body_markdown": "# テストの方法2\n\nファイルを分けるのではなく、同一ファイル内に一旦書くことはできないだろうか？\nRustだと同一ファイル内にテストコードを書けるので、書けないかなと。\n\n## CalvaのRefresh\n\n先ほど読み込んだテストコードをアンロードする必要がある。\nしかし、個別のアンロード機能は無いらしい（AI情報。裏取りはまだしていない）ので、全体読み込み直す必要がある。\n\nコマンドパレットから、`Calva: Refresh All Namespaces`を選択する。\n![](https://storage.googleapis.com/zenn-user-upload/3e726051c727-20241027.png)\n\nすると、Calvaが読み込み直しされた結果でStopするようなので、再度Calvaを立ち上げ直す。\nやり方は以前に書いているので省略。\nREPLサーバーを立ち上げるときと全く一緒。\n\n## 同一ファイルにテストコードを書く\n\n関数コードと同じファイルにテストコードを記載する。\nポイントとしては、インポートにテストライブラリを追加するくらい。\n\n```clojure\n(ns hello-clojure.core\n  (:gen-class)\n  (:require [clojure.test :refer :all]))\n\n\n(defn -main\n  [& args]\n  (println \"Hello, Clojure!\"))\n\n\n(defn fizzbuzz [n]\n  (cond\n    (and (zero? (mod n 3)) (zero? (mod n 5))) \"FizzBuzz\"\n    (zero? (mod n 3)) \"Fizz\"\n    (zero? (mod n 5)) \"Buzz\"\n    :else (str n)))\n\n(doseq [i (range 20)]\n  (println (fizzbuzz i)))\n\n(deftest fizzbuzz-test\n  (testing \"FizzBuzzの動作\")\n  (is (= \"Fizz\" (fizzbuzz 3)))\n  (is (= \"Buzz\" (fizzbuzz 5)))\n  (is (= \"FizzBuzz\" (fizzbuzz 15)))\n  (is (= \"2\" (fizzbuzz 2))))\n```\n\n## テストの実行\n\nテストの実行は、ファイルを分けたときと同じく`Calva: Run Current Test`でOK。\nREPLへのロードは特に必要なかったので、おそらくRefresh時に読み込まれているのではないかと思う。\n\n## テストコードの更新\n\nテストコードを更新したら、REPLに読み込ませる必要がある。\n\nこれは通常のREPL実行のショートカットキーと同様に、`Control + Enter`でできるようだ。\nなお、これは別ファイルに分けた場合もできることが確認できた。\n\n![](https://storage.googleapis.com/zenn-user-upload/0d4a00727fd3-20241027.png)\n\n更新後は、通常のテスト実行と同様に行えば良い。\n\n## 別ファイルに移動\n\n満足するまでテストできたら、別ファイルに移動したらいいのかなと思う。\n本来、そこに書かれるのが正しいだろうし。\n\n## 課題\n\n後々のTodo。\n\n- [ ] アンロードと再起動がめんどくさい。一つのコマンドで実行できないか。\n- [ ] できればコマンドパレットではなく、ショートカットキーなどで手軽に実行したい。\n",
      "body_updated_at": "2024-10-27"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-27",
      "body_markdown": "# TDD\n\nTDDでなにか実装してみる。\n簡単な四則演算アプリを実装してみる。\n\nこれに関しては結果だけ貼っておく。\n\n```clojure\n(ns hello-clojure.core\n  (:gen-class)\n  (:require [clojure.test :refer :all]))\n\n(defn calculation [op a b]\n  (cond\n    (= op \"+\") (+ a b)\n    (= op \"-\") (- a b)\n    (= op \"*\") (* a b)\n    (= op \"/\") (cond\n                  (= b 0) (str \"Division by 0 is not allowed.\")\n                  :else (/ a b))\n    :else \"The operator is incorrect.\"))\n\n(deftest calculation-test\n  (testing \"四則演算関数のテスト\"\n    (is (=(calculation \"+\" 1 2) 3))\n    (is (=(calculation \"-\" 2 1) 1))\n    (is (=(calculation \"*\" 2 3) 6))\n    (is (=(calculation \"/\" 10 2) 5))\n    (is (=(calculation \"/\" 2 10) 2/10))\n    (is (=(calculation \"/\" 10 0) \"Division by 0 is not allowed.\"))\n    (is (=(calculation \"n\" 1 2) \"The operator is incorrect.\"))\n    ))\n```\n\n## リファクタリング\n\nClojure流に書けているかが気になったので、AIに聞いてみて改良する試み。\n\nAI回答のポイントとしては、\n\n- 演算子をHashMapにしてはどうか\n- ハッシュマップにない場合のエラーを表示する形にしてはどうか\n\nといった形であった。\n\nAIに言われたそのままの形であるが、以下のように変更。\n\n```clojure\n(defn calculation \n  [op a b]\n  (let [operations {\"+\" + \n                    \"-\" - \n                    \"*\" * \n                    \"/\" (fn [a b] (if (= b 0)\n                                    \"Division by 0 is not allowed.\"\n                                    (/ a b)))}]\n    (if-let [operation (operations op)]\n      (operation a b)\n      \"Invalid operator.\")))\n\n(deftest calculation-test\n  (testing \"四則演算関数のテスト\"\n    (is (=(calculation \"+\" 1 2) 3))\n    (is (=(calculation \"-\" 2 1) 1))\n    (is (=(calculation \"*\" 2 3) 6))\n    (is (=(calculation \"/\" 10 2) 5))\n    (is (=(calculation \"/\" 2 10) 2/10))\n    (is (=(calculation \"/\" 10 0) \"Division by 0 is not allowed.\"))\n    (is (=(calculation \"n\" 1 2) \"Invalid operator.\"))\n    ))\n```\n\nさらに改良をお願いしたら、\n\n- デフォルトの場合をバインドする\n- テストに名前をつける\n\nという話だったので、コードを変更。\n\n```clojure\n(defn calculation \n  [op a b]\n  (let [operations {\"+\" + \n                    \"-\" - \n                    \"*\" * \n                    \"/\" (fn [a b] \n                          (if-not (= b 0)\n                            (/ a b)\n                            \"Division by 0 is not allowed.\"))}\n        default-fn (fn [_ _] \"Invalid operator.\")] \n    ((or (operations op) default-fn) a b)))\n\n(deftest calculation-test\n  (testing \"四則演算関数のテスト\"\n    (is (=(calculation \"+\" 1 2) 3) \"Addition test failed\")\n    (is (=(calculation \"-\" 2 1) 1) \"Subtraction test failed\")\n    (is (=(calculation \"*\" 2 3) 6) \"Multiplication test failed\")\n    (is (=(calculation \"/\" 10 2) 5) \"Division test failed\")\n    (is (=(calculation \"/\" 2 10) 2/10) \"Fraction division test failed\")\n    (is (=(calculation \"/\" 10 0) \"Division by 0 is not allowed.\") \"Zero division test failed\")\n    (is (=(calculation \"n\" 1 2) \"Invalid operator.\") \"Invalid operator test failed\")\n    ))\n```\n\nいままでのパラダイムと違うので、AIにバンバン質問しながらClojureのスタイルに慣れていきたい。",
      "body_updated_at": "2024-10-29"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-27",
      "body_markdown": "# 更新予定\n\n# Todoアプリのバックエンドを置き換えてみる\n\n以前にGolangで作ったTodoアプリのバックエンドを置き換えて、Clojureをキャッチアップする試み。\n\n以前作ったTodoアプリ\nhttps://github.com/kip2/todo-app-go\n\nTodoアプリのAPIドキュメント\nhttps://kip2.github.io/todo-app-go/\n\n## 参考になると思われる資料\nhttps://qiita.com/lagenorhynque/items/b15689e5432e0170b172\nhttps://qiita.com/lagenorhynque/items/f1e3c75439c1625756f3\n\nhttps://ayato-p.github.io/clojure-beginner/intro_web_development/index.html\n\n## ライブラリやフレームワークの選定\n\nとりあえず候補を挙げてみる。\n\n### フレームワーク\n#### Webフレームワーク\nRing\nhttps://github.com/ring-clojure/ring\n\ncompojure\nhttps://github.com/weavejester/compojure\n\nreitit\nhttps://github.com/metosin/reitit\nhttps://hirake.link/clojure-reitit-api-01/\nhttps://cljdoc.org/d/metosin/reitit/0.7.2/doc/introduction\n\nPedestal\nhttps://github.com/pedestal/pedestal\nhttps://qiita.com/lagenorhynque/items/fbd66ebaa0352ec4253d\n\n#### フルスタックフレームワーク\nLuminus\nhttps://luminusweb.com/\n\n### ライブラリ\n\n#### JSONエンコード/デコード\nCheshire\nhttps://github.com/dakrone/cheshire\n\n#### データバリデーション\nhttps://github.com/metosin/malli\nhttps://zenn.dev/shinseitaro/books/clojure-malli\n\n\n",
      "body_updated_at": "2024-10-29"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-29",
      "body_markdown": "# バブルソート実装\n\n入門したてで右も左もわからないので、AIに聞きながら実装してみる。\nTDDで実装。\n\n## 空のリストを返すテストを書く\n\nまず、空のリストをもらったときにそのまま返すテストを書く。\n\n```clojure\n(deftest bubble-sort-test\n  (testing \"バブルソート関数のテスト\"\n    (is (= (bubble-sort []) []))))\n```\n\n## 空のリストを返す関数を書く\n\n次に、空のリストを返す関数を書く。\n\n```clojure\n(defn bubble-sort \n  [coll] \n  coll)\n```\n\nテストが通るのを確認してフィニッシュ。\n\n## 要素一つの場合\n\n要素を一つだけの場合を書いていく。\n\n```clojure\n(deftest bubble-sort-test\n  (testing \"バブルソート関数のテスト\"\n    (is (= (bubble-sort []) []))\n    (is (= (bubble-sort [1]) [1]))))\n```\n\n実装の方は変える必要がないので、テストが通ることを確認したらフィニッシュ。\n\n## 要素2つの場合\n\n要素2つの場合。\nまずテストコードを追加。\n\n```clojure\n(deftest bubble-sort-test\n  (testing \"バブルソート関数のテスト\"\n    (is (= (bubble-sort []) []))\n    (is (= (bubble-sort [1]) [1]))\n    (is (= (bubble-sort [2 1]) [1 2]))\n    (is (= (bubble-sort [1 2]) [1 2]))))\n```\n\nソートされてないものと、ソートしているものの両方のケースを追加。\n\nさて、最小限度のコードで実装する。\n\n```clojure\n(defn bubble-sort \n  [coll] \n  (if (= (count coll) 2)\n    (if (> (first coll) (second coll))\n      [(second coll) (first coll)]\n      coll)\n    coll))\n```\n\nテストが通ったことを確認してフィニッシュ。\n\n## 要素が3つ以上の場合\n\n要素が3つ以上の場合はちょっと飛躍がいる。\nClojureにふさわしい書き方で実装したいので、AIに聞きながら実装したものがこちら。\n\nテスト含めて、以下のコードになった。\n\n```clojure\n\n(defn bubble-sort-pass \n  [coll] \n  (loop [unsorted coll\n          result []]\n        (cond\n          (empty? unsorted) result\n          (empty? (rest unsorted)) (conj result (first unsorted))\n          :else\n            (let [[a b & rest] unsorted]\n              (if (> a b)\n                (recur (cons a rest) (conj result b))\n                (recur (cons b rest) (conj result a)))))))\n\n(defn bubble-sort [coll]\n  (loop [coll coll]\n    (let [sorted (bubble-sort-pass coll)]\n      (if (= coll sorted)\n        sorted\n        (recur sorted)))))\n\n(deftest bubble-sort-test\n  (testing \"バブルソート関数のテスト\"\n    (is (= (bubble-sort []) []))\n    (is (= (bubble-sort [1]) [1]))\n    (is (= (bubble-sort [2 1]) [1 2]))\n    (is (= (bubble-sort [1 2]) [1 2]))\n    (is (= (bubble-sort [2 1 3]) [1 2 3]))\n    ))\n```",
      "body_updated_at": "2024-10-29"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-30",
      "body_markdown": "# 選択ソート\n\n選択ソートを実装してみる。\n\n```clojure\n(defn selection-sort [coll]\n  (loop [unsorted coll\n        sorted []]\n        (if (empty? unsorted)\n        sorted\n        (let [smallest (apply min unsorted)\n              remainder (remove (fn [x] (= x smallest)) unsorted)]\n          (recur remainder  (conj sorted smallest))))))\n\n(deftest selection-sort-test\n  (testing \"選択ソート関数のテスト\"\n    (is (= (selection-sort []) []))\n    (is (= (selection-sort [1]) [1]))\n    (is (= (selection-sort [2 1]) [1 2]))\n    (is (= (selection-sort [1 2]) [1 2]))\n    (is (= (selection-sort [2 1 3]) [1 2 3]))\n    (is (= (selection-sort [3 2 1]) [1 2 3]))\n    (is (= (selection-sort [5 4 3 2 1]) [1 2 3 4 5]))))\n```",
      "body_updated_at": "2024-10-30"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-30",
      "body_markdown": "# modとremの違い\n\n割り算用の関数にmodとremの2つが存在しており、違いわからなかったため色々調べてみた。\n\n以下の記事に詳しかった。\nhttps://qiita.com/dys7/items/3b05ff52381579075e42\n\n## しかし\n\nremはわかる。\nあまりが1で被除数の符号に揃えるということで理解ができた。\n\nしかし、なぜmodだと2という数字が出てくるのだろうか。\n不思議でならない。\n\n```clojure\n;; modの場合\n(mod 10 3)\n;; 1\n(mod -10 3)\n;; 2\n(mod 10 -3)\n;; -2\n\n;; remの場合\n(rem 10 3)\n;; 1\n(rem -10 3)\n;; -1\n(rem 10 -3)\n;; 1\n```\n\n## AIにきいてみた\n\nググってもよくわからないので、AIに聞いてみた。\n\n:::message\n`mod`で余りが `2` になるのは、「商の切り捨て」という方法で計算しているからです。ここでは、その計算の流れをもう少し直感的に説明してみますね。\n\n### `mod`の計算方法の理解\n\nまず、`mod`と`rem`の計算方法を比較してみます。\n\n- **`rem`** では、単純に「被除数を除数で割った結果の整数部分」を使って計算し、余りの符号は被除数に合わせます。\n  \n- **`mod`** では、同じく被除数を除数で割りますが、ここで「**商を切り捨て**」た結果を使って余りを計算し、その符号は**除数**の符号に合わせます。\n\nつまり、`mod`は商を切り捨てることで「結果の余りを必ず正の方向（または除数の符号に合わせる方向）に合わせる」ために、思ったより大きな数が返ることがあるんです。\n\n### 具体例：`mod -8 5`\n\n1. 被除数 `-8` を除数 `5` で割ると、商は `-1.6` になります。\n   \n2. この商 `-1.6` を切り捨てて、**商を `-2`** にします。\n\n3. 次に、式を以下のように立てます：\n\n   -8 = (-2) * 5 + 2\n\n4. よって、この場合の余りは `2` になります。\n\n### まとめと直感的理解のポイント\n\n- `mod`は「**商を切り捨てて、必ず正の方向（または除数の符号方向）に余りを返す**」という特性があるため、意図的に余りを`2`という大きさで返して、余りが常に除数の符号に合うようにしています。\n\nこの計算方法の目的は、例えば「何かをサイクル的に繰り返す処理」など、余りの正負が変わると困る場面で統一的に使いやすくするためです。そのため、`mod`は特に「符号が予測しやすい剰余」を提供するように設計されています。\n:::\n\n切り捨てしてるんだってさ（まだよくわかってない）。\n\n## modが正しい？\n\nこの記事を読む限り、modの方が正しそうに見える。\n\nhttps://naop.jp/2021/05/29/hunoamari/\n\n\n## modのソースコード\n\nmodのソースコード中にremが使用されてると聞いたので、調査。\nsource関数を使用してmodのソースコードを表示する。\n\n```clojure\n(source mod)\n; (defn mod\n;   \"Modulus of num and div. Truncates toward negative infinity.\"\n;   {:added \"1.0\"\n;    :static true}\n;   [num div] \n;   (let [m (rem num div)] \n;     (if (or (zero? m) (= (pos? num) (pos? div)))\n;       m \n;       (+ m div))))\n```\n\n肝は以下の部分だと思う。\n\n```clojure\n;     (if (or (zero? m) (= (pos? num) (pos? div)))\n;       m \n;       (+ m div))))\n```\n\nmが0、あるいはnumとdivの符号が一致する場合は、mをそのまま返している。\nつまり、\n\n- numが+、divが+\n- numが-、divが-\n- mが0\n\nの場合はそのまま返す（ちなみに短絡評価である）。\n\n+の場合はいいが、-同士の場合はどうだろうか。\n\n```clojure\n(rem -10 -3)\n;; -1\n```\n\nそして、それ以外のばあいは以下のコードが該当する。\n\n```clojure\n;       (+ m div))))\n```\n\nmにdivを足している。\nつまり、考えられるケースは、\n\n- numが-で、divが+\n- numが+で、divが-\n\nの2通り。\n\n具体例で書くと\n\n```clojure\n;; numが-で、divが+\n(rem -10 3)\n;; -1\n\n;; numが+で、divが-\n(rem 10 -3)\n;; 1\n```\n\nこれらの計算結果にdivを足すので、それぞれ以下のようになる。\n\n```clojure\n(+ -1 3)\n;; 2\n\n(+ 1 -3)\n;; -2\n```\n\nソースコードは読み解けたが、なぜこのようにするかは謎のまま。\n\n## modの挙動について\n\n数学のモジュロ演算に基づいているらしい。\nhttps://stackoverflow.com/questions/37210994/difference-between-mod-and-rem-in-clojure\n\n## 剰余演算\n\nwikiに表あり。\nhttps://ja.wikipedia.org/wiki/%E5%89%B0%E4%BD%99%E6%BC%94%E7%AE%97\n\n## remのソースコード\n\n参考だが、remのソースコードはこちら。\n\n```clojure\n; (defn rem\n;   \"remainder of dividing numerator by denominator.\"\n;   {:added \"1.0\"\n;    :static true\n;    :inline (fn [x y] `(. clojure.lang.Numbers (remainder ~x ~y)))}\n;   [num div]\n;     (. clojure.lang.Numbers (remainder num div)))\n```\n\n## remのドキュメント\n\nhttps://clojuredocs.org/clojure.core/rem\nclojure.coreをみると、次のような記載がある。\n\n```clojure\n;; rem and mod are commonly used to get the remainder.\n;; mod means Knuth's mod (truncating towards negativity). \n;; rem implements  ANSI C's % operator\n;; Absolute value stays the same, always the distance\n;; towards zero.\n;; sign depends on dividend.\n```\n\nmodはドナルド・クヌース大先生のいうところの切り捨て法[^1]らしい。\nまた、remはANSI Cの%[^2]を実装したものらしい。\n\n[^1]: wikiによるとこの本に記載があるらしい。https://tatsu-zine.com/books/taocp-vol1\n[^2]: ANSI C (ISO/IEC 9899:1990) に記載があるとのこと。\n\n## 補足\n\nclojure.coreにも色々書いてあるので、参考。\n決定的にどう、というのは書いてなさそう？\n\nhttps://clojuredocs.org/clojure.core/mod",
      "body_updated_at": "2024-10-31"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-30",
      "body_markdown": "# 文字列操作\n\nclojure.stringが文字列操作用のライブラリと聞いたのでメモ。\n\nhttps://clojuredocs.org/clojure.string\n\n一つ一つ簡単に掘り下げていきたい。\n\n別記事を立てて、そちらに記載した。\n\n",
      "body_updated_at": "2024-10-31"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-30",
      "body_markdown": "# 関数について調べる方法\n\n以下の4つが使用できる。\n\n- doc\n- source\n- find-doc\n- apropos\n\n## doc\n\n```clojure\n(doc mod)\n; -------------------------\n; clojure.core/mod\n; ([num div])\n;   Modulus of num and div. Truncates toward negative infinity.\n```\n\n## source\n\n```clojure\n(source mod)\n; (defn mod\n;   \"Modulus of num and div. Truncates toward negative infinity.\"\n;   {:added \"1.0\"\n;    :static true}\n;   [num div] \n;   (let [m (rem num div)] \n;     (if (or (zero? m) (= (pos? num) (pos? div)))\n;       m \n;       (+ m div))))\n```\n\n## find-doc\n\n```clojure\n(find-doc \"mod\")\n\n;; 表示多いため、一部のみ\n; -------------------------\n; clojure.test/set-test\n; ([name & body])\n; Macro\n;   Experimental.\n;   Sets :test metadata of the named var to a fn with the given body.\n;   The var must already exist.  Does not modify the value of the var.\n; \n;   When *load-tests* is false, set-test is ignored.\n; -------------------------\n; cider.nrepl.middleware.debug/skip-breaks!\n; ([mode] [mode coor code force?])\n;   Set the value of *skip-breaks* for the top-level breakpoint.\n;   Additional arguments depend on mode, and should be:\n;    - empty for :all or :trace\n;    - coordinates, code, and force for :deeper or :before\n;   See `skip-breaks?`.\n; -------------------------\n; cider.nrepl.middleware.debug/skip-breaks?\n```\n\n## apropos\n\n```clojure\n(apropos \"selection\")\n(hello-clojure.core/selection-sort hello-clojure.core/selection-sort-test)\n```\n\n## 参考\nhttps://kazuhira-r.hatenablog.com/entry/20121027/1351329786"
    },
    {
      "author": "kip2",
      "created_at": "2024-11-02",
      "body_markdown": "# clojure.spec\n\nこちらの本で紹介されていて気になったので、調査。\nhttps://booth.pm/ja/items/1575586\n\n## そもそもどういうものか\n> Clojureは動的言語なので、型の情報なしで開発を進めていくのが基本です。\n> 動的な言語と静的な言語のどちらが優れているか、という議論は\n以前からありますが、あなたはどうお考えでしょうか。\n> この問題にはさまざまな意見があるかと思いますが、Clojureは動的型付け\nを選択した言語です。\n> しかし、specというライブラリーを使うと、Clojureでも型の恩恵を\n受けることができます。\n\nhttps://qiita.com/Haar/items/3ad988cc75a90ae20a2f\n\n動的型付けであるClojureで型が使えるものということだろうか。\n\n## 使用してみる\n\n```clojure\n;; import\n(require '[clojure.spec.alpha :as s])\n\n;; nameが文字列であることを定義\n;; 型でいうとstring相当\n(s/def ::name string?)\n\n;; 正のintであることを定義\n;; 型でいうとuint相当\n(s/def ::age pos-int?)\n\n;; データを定義\n(def alice {:name \"Alice\" :age 30}) \n(s/valid? ::name (:name alice))\n;; true\n(s/valid? ::age (:age alice))\n;; true\n\n;; データを定義\n(def bob {:name \"Bob\" :age -5}) \n(s/valid? ::name (:name bob))\n;; true\n(s/valid? ::age (:age bob))\n;; false\n```\n\n# 参考にした文献\nhttps://booth.pm/ja/items/1575586",
      "body_updated_at": "2024-11-02"
    },
    {
      "author": "kip2",
      "created_at": "2024-11-02",
      "body_markdown": "# 設定変更\n\nCalvaのフォーマット設定が自分と合わなかったので設定変更する。\n\n## 何をしたいか\n\nTabキー押したときのフォーマットを無効化したい。\nTabキー押したときにフォーマットされると、自分の想定していないところにカーソルが行くので戸惑っていますので。\n\n## 公式ドキュメント\n\nフォーマットに関してはこちらの公式ページがあるので、こちらを参照して変えていく。\nhttps://calva.io/formatting/\n\n## 実施に変えてみる\n\n### VSCodeの設定変更\nまず、VSCodeのファイル保存時のオートフォーマットを有効化する。\nTabキー押下時のフォーマットは防ぎたいが、フォーマットそのものはほしいので、ファイル保存時のものを有効化する。\n\n> Also: If you have Format on Save enabled in VS Code, it will be Calva doing the formatting for Clojure files.\n\n![](https://storage.googleapis.com/zenn-user-upload/580db4aee378-20241102.png)\n\n### Calvaのキーバインドを無効\n\nキーバインドそのものを無効化する。\n特にキーバインドを使用していなかったので、一旦この対応で問題ないと思う。\n\n![](https://storage.googleapis.com/zenn-user-upload/a41abbbd6491-20241102.png)\n\n## 問題発生\n\nデフォルトキーバインド使ってないと思っていたら、コードの実行で使用していた(`Control + Enter`)。\n\nなので、なんとかしてデフォルトのTabキーのみを設定変更する必要がある。\n\n## キーバインドの変更\n\nまずVSCodeのキーボードショートカットの設定を開く。\nMacを使用しているので、`Cmd + S`で開く。\n\n検索欄に`calva`と入力し、Tabキーを探す。\n\n![](https://storage.googleapis.com/zenn-user-upload/707c6915d5d7-20241102.png)\n\nあとは適当なキーに変更したらOK。\n\n![](https://storage.googleapis.com/zenn-user-upload/ad2680f31a6c-20241102.png)\n\nこれでTabキーのフォーマットを無効化し、その他のキーバインドは使える状態になった。\n\n## 記事化\n\n今後キーマップ変更したいときがあるとおもうので、記事として残すことにした。\nhttps://zenn.dev/kip2/articles/3efd77d21721a8\n",
      "body_updated_at": "2024-11-02"
    }
  ]
}