{
  "title": "Go言語によるTodoアプリの作成ログ",
  "closed": true,
  "archived": false,
  "created_at": "2024-09-29",
  "comments": [
    {
      "author": "kip2",
      "created_at": "2024-09-29",
      "body_markdown": "Go言語でTodoアプリを作成するので、ログを残す試み\n\n以下の書籍を参考とする予定\nhttps://gihyo.jp/book/2023/978-4-297-13419-8\n\n経緯としては\n・人に教える必要が出たため、Todoアプリを題材にしようと思った\n・ついでに自分もGoに入門したい\n・mattnさんの以下の記事に触発されて、ベースとなるTodoアプリを作りたかった\nhttps://levtech.jp/media/article/column/detail_473/\nといったところ\n\nなお、人に教えるときに共有するログになるため、記述がかなり冗長になると思われる\n",
      "body_updated_at": "2024-10-01"
    },
    {
      "author": "kip2",
      "created_at": "2024-09-30",
      "body_markdown": "参考書籍に従って、以下のものを使用してみる予定。\n難しすぎたり、要件に合わない場合はそのときにまた検討しようと思う。\n\nフレームワーク：labstack/echo\nhttps://echo.labstack.com/\nテンプレートエンジン：html/template\nhttps://pkg.go.dev/html/template\nORM：uptrace/bun\nhttps://bun.uptrace.dev/",
      "body_updated_at": "2024-10-01"
    },
    {
      "author": "kip2",
      "created_at": "2024-09-30",
      "body_markdown": "まずDB周りのコードを学んで書いていこうと思っていたが、Rustで慣れ親しんだsqlxがgoに見つかったので、こっちを使うように方針変更\n見切り発車なので、今後もこうやって方針をどしどし変えていくと思われる\nhttps://github.com/jmoiron/sqlx",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "kip2",
      "created_at": "2024-09-30",
      "body_markdown": "# Goのプラグインをインストール\nDB接続のためのプラグインを、まずはインストール\n\n```sh\n# sqlx\ngo get github.com/jmoiron/sqlx\n# driver\ngo get github.com/go-sql-driver/mysql\n# dotenv\ngo get github.com/joho/godotenv\n```\n.envからの読み込み用に以下も追加\nhttps://github.com/joho/godotenv",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "kip2",
      "created_at": "2024-09-30",
      "body_markdown": "# .envからの値の読み込み\n.envから読み込みをする処理を書いていく\n\nまず、.envにテスト用の環境変数を記載する\n\n```ini\nTEST_VALUE=\"test value of dotenv\"\n```\n\n次に、go側でこれを読み込んで表示するコードを書く\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/joho/godotenv\"\n)\n\nfunc main() {\n\terr := godotenv.Load()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error loading .env file: %v\", err)\n\t}\n\n\tenv := os.Getenv(\"TEST_VALUE\")\n\n\tfmt.Println(env)\n}\n```\n\n結果\n\n```bash\n$ go run main.go\ntest value of dotenv\n```\n\n取得できたので成功！\nあとは本番用の環境変数に変更すればOK\n\n（余談：.envのコードブロックはiniと書くとハイライトしてくれるんだね。最初envと書いてたけど、ハイライトしなかったので...）",
      "body_updated_at": "2024-10-01"
    },
    {
      "author": "kip2",
      "created_at": "2024-09-30",
      "body_markdown": "そういえばgoの命名規則を意識できてなかったのでこちらを参考にしよう\npython、Rustとやってきたので、意識しないとスネークケースで書いてしまう...\n\nhttps://zenn.dev/kenghaya/articles/1b88417b1fa44d",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "kip2",
      "created_at": "2024-09-30",
      "body_markdown": "# リファクタリング\nリファクタリングして関数に切り出し\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/joho/godotenv\"\n)\n\nfunc main() {\n\tenv := loadEnv(\"TEST_VALUE\")\n\tfmt.Println(env)\n}\n\nfunc loadEnv(key string) string {\n\terr := godotenv.Load()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error loading .env file: %v\", err)\n\t}\n\n\tenv := os.Getenv(key)\n\n\treturn env\n}\n\n```\n\nちゃんと結果も確かめながら、細かいステップを踏みながら進みましょうね〜、ということで動作確認\n\n```sh\n$ go run main.go\ntest value of dotenv\n```\n\nOK！",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "kip2",
      "created_at": "2024-09-30",
      "body_markdown": "先にDBの準備がいるのを忘れていた"
    },
    {
      "author": "kip2",
      "created_at": "2024-09-30",
      "body_markdown": "# MySQLのインストール方法\nMySQLを使用するので、インストール方について書く\nなお、MacとHomebrewを使用する前提\n\n### インストール\n```sh\nbrew install mysql\n```\n\n### サービスの起動\n```sh\nbrew services start mysql\n```\n\n起動確認は以下のコマンドで行える\n\n```sh\nbrew services list\n```\n\n### 初期設定\n\n```sh\nmysql -u root\n```\n\nアクセスしたら以下のコマンドでパスワードを設定する\n```sh\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '新しいパスワード';\n```\n\n### ログイン\nこれでセットアップができたので、今後は、以下のコマンドでmysqlへのログインが行える\n```sh\nmysql -u root -p\n# パスワードの入力が求められるので、パスワードを入力する\n\n# ログイン成功すると、ターミナル上で以下の表示になる\nmysql> \n```",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "kip2",
      "created_at": "2024-09-30",
      "body_markdown": "# DB接続テスト用のテーブルを用意する\n前提として、mysqlにログインしておくこと\nターミナルが以下の状態であればOK\n```sql\nmysql>\n```\n\n### データベースの作成\nまずはテスト用のデータベースを作成する\n\n```sql\nmysql> CREATE DATABASE your_database_name;\n```\n\n::: message\nsqlのコマンドは小文字と大文字を区別しないので、すべて小文字で書いてもOK\n```sql\nmysql> create database your_database_name;\n```\n通常は分かりやすくするためにコマンドを大文字で打つのが慣習となっているが、自分で使う分には混乱しなければどちらでもよい\n:::\n\n### データベースの使用\n作成したデータベースを使用状態にする\n```sql\nmysql> USE your_database_name;\n```\n\n### テーブルの作成\n接続テスト用のテーブルを作成する\n\n```sql\nmysql> CREATE TABLE users(\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(100) NOT NULL\n);\n```\n\nテーブルが作成できたか確認する\n```sql\nmysql> SHOW TABLES;\n```\n\nなお、テーブル構造の確認には次のコマンドを使用する\n```sql\nmysql> DESCRIBE users;\n```\n\n### 初期データの投入\nテスト用のデータをDBに登録する\n\n```sql\nmysql> INSERT INTO users (name) VALUES ('Alice');\nmysql> INSERT INTO users (name) VALUES ('Bob');\n```\n\nデータが登録されているかを確認する\n```sql\nmysql> SELECT * FROM users;\n```",
      "body_updated_at": "2024-09-30"
    },
    {
      "author": "kip2",
      "created_at": "2024-09-30",
      "body_markdown": "# テーブル接続のGoのコードを書く\n作成したテーブルのデータと対応する構造体を定義する\n\n```go\ntype User struct {\n\tID int `db:\"id\"`\n\tName string `db:\"name\"`\n}\n```\n\nこの構造体を使って、DBのデータを受け取って表示するコードを書く\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n\t\"github.com/jmoiron/sqlx\"\n\t\"github.com/joho/godotenv\"\n)\n\ntype User struct {\n\tID   int    `db:\"id\"`\n\tName string `db:\"name\"`\n}\n\nfunc main() {\n\n\t// .envから環境変数の値を読み込み\n\tdsn := loadEnv(\"DATABASE\")\n\n\t// dbとのコネクションを作成\n\tdb, err := sqlx.Connect(\"mysql\", dsn)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\t// dbコネクションを閉じるためのデコンストラクタ\n\tdefer db.Close()\n\n\t// クエリを実行して結果を取得\n\tvar users []User\n\terr = db.Select(&users, \"SELECT id, name FROM users WHERE id=?\", 1)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\t// クエリした結果を表示して確認\n\tfor _, user := range users {\n\t\tfmt.Printf(\"ID: %d, Name: %s\\n\", user.ID, user.Name)\n\t}\n}\n\nfunc loadEnv(key string) string {\n\terr := godotenv.Load()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error loading .env file: %v\", err)\n\t}\n\n\tenv := os.Getenv(key)\n\n\treturn env\n}\n\n```\n\n実行して確認\n\n```sh\n$ go run main.go\nID: 1, Name: Alice\n```\n\n",
      "body_updated_at": "2024-10-01"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-01",
      "body_markdown": "# リファクタリング\n\nここまでのコードのなかで、リファクタリングしたいところを挙げる\n\n- [ ] DBコネクション取得は外部関数に切り出したい\n- [ ] クエリの実行を外部関数に切り出したい\n\n上は今やってもいいけど、下のは一旦保留かな～\nあくまでテスト用のDB接続なので、切り出すには早い気がする\n",
      "body_updated_at": "2024-10-01"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-01",
      "body_markdown": "# DBコネクション取得を外部関数化\n\nDBコネクション取得の外部関数への切り出し\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n\t\"github.com/jmoiron/sqlx\"\n\t\"github.com/joho/godotenv\"\n)\n\ntype User struct {\n\tID   int    `db:\"id\"`\n\tName string `db:\"name\"`\n}\n\nfunc main() {\n\n\t// dbとのコネクションを作成\n\tdb := createDBConnection()\n\n\t// dbコネクションを閉じるためのデコンストラクタ\n\tdefer db.Close()\n\n\t// クエリを実行して結果を取得\n\tvar users []User\n\terr := db.Select(&users, \"SELECT id, name FROM users WHERE id=?\", 1)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\t// クエリした結果を表示して確認\n\tfor _, user := range users {\n\t\tfmt.Printf(\"ID: %d, Name: %s\\n\", user.ID, user.Name)\n\t}\n}\n\nfunc createDBConnection() *sqlx.DB {\n\tdsn := loadEnv(\"DATABASE\")\n\n\tdb, err := sqlx.Connect(\"mysql\", dsn)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\treturn db\n}\n\nfunc loadEnv(key string) string {\n\terr := godotenv.Load()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error loading .env file: %v\", err)\n\t}\n\n\tenv := os.Getenv(key)\n\n\treturn env\n}\n```\n\n動作確認\n\n```sh\n$ go run main.go\nID: 1, Name: Alice\n```",
      "body_updated_at": "2024-10-01"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-01",
      "body_markdown": "今後、関数への切り出しが増えていくと何をする関数かぱっと見わからなくなるので、後のことを考えてドキュメントを追加\n\ngodocに使える形で記載するのを目標にしたい\n以下は参考記事\nhttps://qiita.com/shibukawa/items/8c70fdd1972fad76a5ce\nhttps://zenn.dev/harachan/articles/db3149c1a19c32\n\n```go\n// DBコネクションを作成する関数\nfunc createDBConnection() *sqlx.DB {\n\tdsn := loadEnv(\"DATABASE\")\n\n\tdb, err := sqlx.Connect(\"mysql\", dsn)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\treturn db\n}\n\n// .envファイルから特定のキーに紐づく値を取得する関数\nfunc loadEnv(key string) string {\n\terr := godotenv.Load()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error loading .env file: %v\", err)\n\t}\n\n\tenv := os.Getenv(key)\n\n\treturn env\n}\n```",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-01",
      "body_markdown": "コメントの形式間違えたので修正\n```go\n/*\nDBコネクションを作成する関数\n*/\nfunc createDBConnection() *sqlx.DB {\n\tdsn := loadEnv(\"DATABASE\")\n\n\tdb, err := sqlx.Connect(\"mysql\", dsn)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\treturn db\n}\n\n/*\n.envファイルから特定のキーに紐づく値を取得する関数\n*/\nfunc loadEnv(key string) string {\n\terr := godotenv.Load()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error loading .env file: %v\", err)\n\t}\n\n\tenv := os.Getenv(key)\n\n\treturn env\n}\n```",
      "body_updated_at": "2024-10-01"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-01",
      "body_markdown": "リポジトリ切ってなかったのを思い出したのでリポジトリを切ることにする\nコミットは途中からになるけど、練習用に作ってるんだしまあいいかの精神\n\nhttps://github.com/kip2/todo-app-go",
      "body_updated_at": "2024-10-01"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-01",
      "body_markdown": "ちょっとリファクタリング\n環境変数指定のハードコーディングをやめて、引数で受け取れるように変更\n\n```go\n/*\nDBコネクションを作成する関数\n*/\nfunc createDBConnection(envKey string) *sqlx.DB {\n\tdsn := loadEnv(envKey)\n\n\tdb, err := sqlx.Connect(\"mysql\", dsn)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\treturn db\n}\n```\n\n使用側のコードは以下となる\n```go\n// dbとのコネクションを作成\nenvKey := \"DATABASE\"\ndb := createDBConnection(envKey)\n```",
      "body_updated_at": "2024-10-01"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-01",
      "body_markdown": "ところで変数の名前、envKeyで意味あってるのだろうか...\n\n「環境変数のキー」なんて言い回ししないよな〜となんとなく思った\n環境変数は環境変数だし\n\nというわけで変数名を修正\n```go\n/*\nDBコネクションを作成する関数\n*/\nfunc createDBConnection(envVar string) *sqlx.DB {\n\tdsn := loadEnv(envVar)\n\n\tdb, err := sqlx.Connect(\"mysql\", dsn)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\treturn db\n}\n```\n\n省略するが、呼び出し側も同様に変更している\n\n::: message\nVScodeでは`F2`キーを使うと、変数名を簡単に変えられるのでおすすめ\n一箇所変更すれば、変数の登場する箇所がすべて変わる便利機能\n参考記事\nhttps://note.com/yuto_tetsuka/n/n3a4038c1e904\n:::\n\n",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-01",
      "body_markdown": "# テストコードの作成\n\n関数切り出しも行ったので、テストコードを書いて、今後、コードの変更をする場合の動作を担保したいと思う\n\nとりあえず`main_test.go`を作成する\n例としてはtouchを使用して作成しているが、GUIを介して作成してもOK\n注意としては、main.goと同じディレクトリに配置すること\n```sh\ntouch main_test.go\n```\n\n```go\npackage main\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestLoadEnv(t *testing.T) {\n\tos.Setenv(\"DATABASE\", \"test-dsn\")\n\tdsn := loadEnv(\"DATABASE\")\n\tassert.Equal(t, \"test-dsn\", dsn, \"環境変数の値が正しく読み込まれていません\")\n}\n\nfunc TestCreateDBConnection(t *testing.T) {\n\tdb := createDBConnection(\"DATABASE\")\n\tdefer db.Close()\n\n\tassert.NotNil(t, db, \"DBコネクションが作成されていません\")\n}\n\n```\n\nこれで、テスト対象の関数に変更があった場合に、ちゃんと動作するかを確かめることができる\nとはいえ、テストケースを網羅したわけではないので、限定的にはなるけども\n",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-01",
      "body_markdown": "テスト用DBに接続テストしていたコードを、テストコードとして切り出し\n\n```go\npackage main\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// TestDB用の型定義なので、main関数から型定義を移動\ntype User struct {\n\tID   int    `db:\"id\"`\n\tName string `db:\"name\"`\n}\n\n/*\nテスト用DBへの接続と値の取得テスト\n*/\nfunc TestDBQuery(t *testing.T) {\n\tenvVar := \"DATABASE\"\n\tdb := createDBConnection(envVar)\n\tdefer db.Close()\n\n\tvar users []User\n\terr := db.Select(&users, \"SELECT id, name FROM users WHERE id=?\", 1)\n\n\t// クエリ実行時のエラーをテスト\n\tassert.NoError(t, err, \"クエリ実行時にエラーが発生しました\")\n\n\t// 期待するUserデータ\n\tvar expectedUser = User{\n\t\tID:   1,\n\t\tName: \"Alice\",\n\t}\n\n\t// テスト用ユーザーデータの取得をアサート\n\tassert.Equal(t, 1, len(users), \"ユーザーが取得できませんでした\")\n\tassert.Equal(t, expectedUser.ID, users[0].ID, \"ユーザーIDが一致しません\")\n\tassert.Equal(t, expectedUser.Name, users[0].Name, \"ユーザー名が一致しません\")\n}\n\nfunc TestLoadEnv(t *testing.T) {\n\tos.Setenv(\"DATABASE\", \"test-dsn\")\n\tdsn := loadEnv(\"DATABASE\")\n\tassert.Equal(t, \"test-dsn\", dsn, \"環境変数の値が正しく読み込まれていません\")\n}\n\nfunc TestCreateDBConnection(t *testing.T) {\n\tdb := createDBConnection(\"DATABASE\")\n\tdefer db.Close()\n\n\tassert.NotNil(t, db, \"DBコネクションが作成されていません\")\n}\n```\n\nだいぶん脇にそれたけど、これでDBとの接続テストがいつでも行えるようになった",
      "body_updated_at": "2024-10-01"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-02",
      "body_markdown": "# INSERTの場合\n\nINSERTの場合の書き方\n\n```go\nfunc main() {\n\tenvVar := \"DATABASE\"\n\tdb := createDBConnection(envVar)\n\tdefer db.Close()\n\n\tname := \"Charlie\"\n\n\tresult, err := db.Exec(\"INSERT INTO users (name) VALUES (?)\", name)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tlastInsertID, err := result.LastInsertId()\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tfmt.Printf(\"Inserted user with ID: %d\\n\", lastInsertID)\n}\n```",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-02",
      "body_markdown": "# エラーハンドリングについて\n毎回以下のコードを書くのが面倒なのでマクロ化したい\n\n```go\nif err != nil {\n    log.Fatalln(err)\n}\n```\n\nしかし、Go言語にはマクロはないっぽいので、関数で記載する（単に見つけられてないだけかも）\n\n```go\n/*\nエラーハンドリング用のコード(マクロ代わり)\n*/\nfunc checkError(err error) {\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n}\n```\n\n使い方は以下の用にすればいい\n\n```go\ncheckError(err)\n```\n\n一例として、先程のコードを直したものを示す\n\n```go\n\nfunc main() {\n\tenvVar := \"DATABASE\"\n\tdb := createDBConnection(envVar)\n\tdefer db.Close()\n\n\tname := \"Charlie\"\n\n\tresult, err := db.Exec(\"INSERT INTO users (name) VALUES (?)\", name)\n\t// エラーハンドリング\n\tcheckError(err)\n\n\tlastInsertID, err := result.LastInsertId()\n\t// エラーハンドリング\n\tcheckError(err)\n\n\tfmt.Printf(\"Inserted user with ID: %d\\n\", lastInsertID)\n}\n\n/*\nエラーハンドリング用のコード(マクロ代わり)\n*/\nfunc checkError(err error) {\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n}\n```",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-02",
      "body_markdown": "# INSET関数の再利用のために\n\n後々再利用する可能性もあるため、一旦外部関数として切り出す\nとはいえ、接続テスト用のDBに対するコードのため今後再利用の可能性はないと思うが、まあ切り出し方の手順として、ね？\n\n```go\nfunc main() {\n\tname := \"David\"\n\tinsert(name)\n}\n\nfunc insert(name string) {\n\tenvVar := \"DATABASE\"\n\tdb := createDBConnection(envVar)\n\tdefer db.Close()\n\n\tresult, err := db.Exec(\"INSERT INTO users (name) VALUES (?)\", name)\n\tcheckError(err)\n\n\tlastInsertID, err := result.LastInsertId()\n\tcheckError(err)\n\n\tfmt.Printf(\"Inserted user with ID: %d\\n\", lastInsertID)\n}\n```\n",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-02",
      "body_markdown": "# sqlxの参考資料\n\nhttps://zenn.dev/robon/articles/ff2419b7f5a76c"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-02",
      "body_markdown": "ぼちぼち関数が散らかってきたので、整理しよう"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-02",
      "body_markdown": "# フォルダ整理\n\nmain.goにすべての関数を書いているので、各関数を機能ごとにまとめる形に修正する\nフォルダを切って、別パッケージとする\n具体的には以下の構造とする\n\n```sh\n.\n├── db\n│   └── db.go\n├── env\n│   └── env.go\n├── error\n│   └── error.go\n├── go.mod\n├── go.sum\n├── main.go\n└── main_test.go\n\n4 directories, 7 files\n```\n\n個別のコードは以下に示す\n\n## db\n\n```go\npackage db\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"todoApp/env\"\n\terrorpkg \"todoApp/error\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n\t\"github.com/jmoiron/sqlx\"\n)\n\n/*\nデータをDBにINSERTする\n*/\nfunc Insert(name string) {\n\tenvVar := \"DATABASE\"\n\tdb := CreateDBConnection(envVar)\n\tdefer db.Close()\n\n\tresult, err := db.Exec(\"INSERT INTO users (name) VALUES (?)\", name)\n\terrorpkg.CheckError(err)\n\n\tlastInsertID, err := result.LastInsertId()\n\terrorpkg.CheckError(err)\n\n\tfmt.Printf(\"Inserted user with ID: %d\\n\", lastInsertID)\n}\n\n/*\nMySQLのDBコネクションを作成する関数\n*/\nfunc CreateDBConnection(envVar string) *sqlx.DB {\n\tdsn := env.LoadEnv(envVar)\n\n\tdb, err := sqlx.Connect(\"mysql\", dsn)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\treturn db\n}\n```\n\n## env\n\n```go\npackage env\n\nimport (\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/joho/godotenv\"\n)\n\n/*\n.envファイルから特定のキーに紐づく値を取得する関数\n*/\nfunc LoadEnv(key string) string {\n\t// .envに定義した環境変数をロード\n\terr := godotenv.Load()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error loading .env file: %v\", err)\n\t}\n\n\t// 環境変数から値を取得\n\tenv := os.Getenv(key)\n\n\treturn env\n}\n```\n\n## error\n\n予約後のため、package名に`error`は使えないとのこと\n`errorpkg`としている\n\n```go\npackage errorpkg\n\nimport \"log\"\n\n/*\nエラーハンドリング用\n*/\nfunc CheckError(err error) {\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n}\n```\n\n## main\n\nmain.goがスッキリした\n\n```go\npackage main\n\nimport \"todoApp/db\"\n\nfunc main() {\n\tname := \"David\"\n\tdb.Insert(name)\n}\n```",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-02",
      "body_markdown": "sqlxの動作確認はこれでいいと思うので、実際にTodoアプリで使うDB設計をしようと思う"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-02",
      "body_markdown": "# DB設計\n\n参考書籍から丸パクリだが、以下のDBとしたい\n\n```mermaid\nerDiagram\n\tTODOS {\n\t\tID INT PK \"AUTO_INCREMENT\"\n\t\tContent VARCHAR  \"NOT NULL\"\n\t\tDone BOOLEAN  \"TINYINT(1)\"\n\t\tUntile DATETIME\n\t\tCreatedAt DATETIME  \"DEFAULT CURRENT_TIMESTAMP\"\n\t\tUpdatedAt DATETIME \"DEFAULT CURRENT_TIMESTAMP ON UPDATE\"\n\t\tDeletedAt DATETIME\n\t}\n```\n\nSQLに起こしたもの\n\n```sql\nCREATE TABLE todos (\n    ID INT AUTO_INCREMENT PRIMARY KEY,\n    Content VARCHAR(255) NOT NULL,\n    Done TINYINT(1) NOT NULL DEFAULT 0,\n    Until DATETIME,\n    CreatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    UpdatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    DeletedAt DATETIME DEFAULT NULL\n);\n```\n\nMySQLにログインして、このテーブルを作成しておく\n\n```sql\nmysql> CREATE TABLE todos (\n    ->     ID INT AUTO_INCREMENT PRIMARY KEY,\n    ->     Content VARCHAR(255) NOT NULL,\n    ->     Done TINYINT(1) NOT NULL DEFAULT 0,\n    ->     Until DATETIME,\n    ->     CreatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    ->     UpdatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    ->     DeletedAt DATETIME DEFAULT NULL\n    -> );\n```\n\n実際に作成されているかを確認する\n\n```sql\nmysql> show tables;\n+--------------------+\n| Tables_in_todo_app |\n+--------------------+\n| todos              |\n| users              |\n+--------------------+\n2 rows in set (0.00 sec)\n\nmysql> describe todos;\n+-----------+--------------+------+-----+-------------------+-----------------------------------------------+\n| Field     | Type         | Null | Key | Default           | Extra                                         |\n+-----------+--------------+------+-----+-------------------+-----------------------------------------------+\n| ID        | int          | NO   | PRI | NULL              | auto_increment                                |\n| Content   | varchar(255) | NO   |     | NULL              |                                               |\n| Done      | tinyint(1)   | NO   |     | 0                 |                                               |\n| Until     | datetime     | YES  |     | NULL              |                                               |\n| CreatedAt | datetime     | NO   |     | CURRENT_TIMESTAMP | DEFAULT_GENERATED                             |\n| UpdatedAt | datetime     | NO   |     | CURRENT_TIMESTAMP | DEFAULT_GENERATED on update CURRENT_TIMESTAMP |\n| DeletedAt | datetime     | YES  |     | NULL              |                                               |\n+-----------+--------------+------+-----+-------------------+-----------------------------------------------+\n7 rows in set (0.01 sec)\n```",
      "body_updated_at": "2024-10-09"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-02",
      "body_markdown": "# API設計\n\nさて、色々準備できたので、バックエンドの動作を作り込んでいく\n今回、バックエンドはAPIとしてフロントとやり取りを行い、DBから読み出したり、DBに登録したりする機能で行こうと思う\n\nまずはAPIの設計から\n\nほしい要件を箇条書きする\n- APIとはJSON形式でやり取りする\n- Todoリストの一覧表示のための、すべてのTodoを取得するエンドポイント\n- ContentとUntilの値をJSONでPOSTし、データベースに登録するエンドポイント\n- IDと紐づいたTodoの削除を行うエンドポイント\n\nさて、各要件を細かく詰めていこう\n\n## Todo一覧表示のためのエンドポイント\n\nまず一覧表示のためのエンドポイント\n- getで要求したら全てのデータがJSONで返ってくる\n- Todos型の値として返ってくる\n- ID, Content, Until, Doneあたりを受け取るのみでいいと思うが、すべてのカラムを受け取る形で一旦考えること\n\n## Todoをデータベースに登録するエンドポイント\n\n次にDB登録用のエンドポイント\n- ContentとUntilが記載されているJSONを受け取る\n- 登録できたか否かをレスポンスする機能は、処理簡易化のため、今回は作らない\n\n## Todoを削除するエンドポイント\n\n最後にTodoを削除するエンドポイント\n- TodoのIDの記載があるJSONを受け取る\n- DBにあるIDと紐づくTodoのDeletedAtを更新する\n\n## 気づき\nDeletedAtの扱いが微妙な感じがする...\nあとあと、ここは変更するかも\n\n",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-02",
      "body_markdown": "# Todo取得処理\n\n## ダミーデータの登録\n\n取得確認のためのダミーデータを登録する\n他の項目は自動で埋まるか、NULL許容しているデータのため、Contentのみをインサートすればデータは作れる\n\n```go\nmysql> INSERT INTO todos (Content) VALUES (\"test todo\");\nQuery OK, 1 row affected (0.01 sec)\n\nmysql> select * from todos;\n+----+-----------+------+-------+---------------------+---------------------+-----------+\n| ID | Content   | Done | Until | CreatedAt           | UpdatedAt           | DeletedAt |\n+----+-----------+------+-------+---------------------+---------------------+-----------+\n|  1 | test todo |    0 | NULL  | 2024-10-02 20:21:16 | 2024-10-02 20:21:16 | NULL      |\n+----+-----------+------+-------+---------------------+---------------------+-----------+\n1 row in set (0.01 sec)\n```\n\n## ダミーデータの取得処理\n\n一旦、main.goに定義する\ndb.goに書くのが適切だが、golangでの外部パッケージへの定義がよく分かっていないため、リファクタリングの中で行うことにする\nまずは動くコードを書くのが先決\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\t\"todoApp/db\"\n\terrorpkg \"todoApp/error\"\n)\n\n// DBに紐づくデータの定義\ntype Todo struct {\n\tID        int        `db:\"ID\"`\n\tContent   string     `db:\"Content\"`\n\tDone      bool       `db:\"Done\"`\n\tUntil     *time.Time `db:\"Until\"`\n\tCreatedAt time.Time  `db:\"CreatedAt\"`\n\tUpdatedAt time.Time  `db:\"UpdatedAt\"`\n\tDeletedAt *time.Time `db:\"DeletedAt\"`\n}\n\nfunc main() {\n\n\tenvVar := \"DATABASE\"\n\tdb := db.CreateDBConnection(envVar)\n\tdefer db.Close()\n\n\tvar todo Todo\n\terr := db.Get(&todo, \"SELECT * FROM todos WHERE id=?\", 1)\n\terrorpkg.CheckError(err)\n\n\tfmt.Printf(\"Todo: %+v\\n\", todo)\n}\n```\n\n動作確認\n\n```sh\n$ go run main.go\nTodo: {ID:1 Content:test todo Done:false Until:<nil> CreatedAt:2024-10-02 20:21:16 +0900 JST UpdatedAt:2024-10-02 20:21:16 +0900 JST DeletedAt:<nil>}\n```\n\n## 外部関数に切り出す\n\nIDによる取得処理を外部関数に切り出す\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\t\"todoApp/db\"\n\terrorpkg \"todoApp/error\"\n)\n\ntype Todo struct {\n\tID        int        `db:\"ID\"`\n\tContent   string     `db:\"Content\"`\n\tDone      bool       `db:\"Done\"`\n\tUntil     *time.Time `db:\"Until\"`\n\tCreatedAt time.Time  `db:\"CreatedAt\"`\n\tUpdatedAt time.Time  `db:\"UpdatedAt\"`\n\tDeletedAt *time.Time `db:\"DeletedAt\"`\n}\n\nfunc main() {\n\ttodo := selectById(1)\n\tfmt.Printf(\"Todo: %+v\\n\", todo)\n}\n\n/*\n指定したIDのTodoをDBから取得する\n*/\nfunc selectById(id int) Todo {\n\tenvVar := \"DATABASE\"\n\tdb := db.CreateDBConnection(envVar)\n\tdefer db.Close()\n\n\tvar todo Todo\n\terr := db.Get(&todo, \"SELECT * FROM todos WHERE id=?\", id)\n\terrorpkg.CheckError(err)\n\n\treturn todo\n}\n```\n\n## db.goへコードを移動\nあとはこれをdb.goに移動すれば良い\n移動したのが以下のコードとなる\n\nあと、ついでに環境変数はグローバル変数に変更した\nこうすることで変更するときもここだけ変えれば良くなるので\n\ndb.go\n```go\npackage db\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\t\"todoApp/env\"\n\terrorpkg \"todoApp/error\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n\t\"github.com/jmoiron/sqlx\"\n)\n\n// グローバル変数として定義した\nconst envVar = \"DATABASE\"\n\ntype Todo struct {\n\tID        int        `db:\"ID\"`\n\tContent   string     `db:\"Content\"`\n\tDone      bool       `db:\"Done\"`\n\tUntil     *time.Time `db:\"Until\"`\n\tCreatedAt time.Time  `db:\"CreatedAt\"`\n\tUpdatedAt time.Time  `db:\"UpdatedAt\"`\n\tDeletedAt *time.Time `db:\"DeletedAt\"`\n}\n\n/*\n指定したIDのTodoをDBから取得する\n*/\nfunc SelectById(id int) Todo {\n\tdb := CreateDBConnection(envVar)\n\tdefer db.Close()\n\n\tvar todo Todo\n\terr := db.Get(&todo, \"SELECT * FROM todos WHERE id=?\", id)\n\terrorpkg.CheckError(err)\n\n\treturn todo\n}\n\n/*\nデータをDBにINSERTする(test用)\n*/\nfunc Insert(name string) {\n\tdb := CreateDBConnection(envVar)\n\tdefer db.Close()\n\n\tresult, err := db.Exec(\"INSERT INTO users (name) VALUES (?)\", name)\n\terrorpkg.CheckError(err)\n\n\tlastInsertID, err := result.LastInsertId()\n\terrorpkg.CheckError(err)\n\n\tfmt.Printf(\"Inserted user with ID: %d\\n\", lastInsertID)\n}\n\n/*\nMySQLのDBコネクションを作成する関数\n*/\nfunc CreateDBConnection(envVar string) *sqlx.DB {\n\tdsn := env.LoadEnv(envVar)\n\n\tdb, err := sqlx.Connect(\"mysql\", dsn)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\treturn db\n}\n```\n\n接続テスト用の関数はいらないため、そのうち削除予定\n今のところはそのままおいている\n",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-02",
      "body_markdown": "## 複数データの取得\n\n目的は全てのデータの取得のため、リストで受け取る必要がある\n\n## ダミーデータの追加\n\n複数件受け取る処理をテストするためのダミーデータを追加する\n1件でもよいが、せっかくなので2件追加した\n\n```sql\n\nmysql> INSERT INTO todos (Content) VALUES (\"test todo2\");\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> INSERT INTO todos (Content) VALUES (\"test todo3\");\nQuery OK, 1 row affected (0.01 sec)\n\nmysql> select * from todos;\n+----+------------+------+-------+---------------------+---------------------+-----------+\n| ID | Content    | Done | Until | CreatedAt           | UpdatedAt           | DeletedAt |\n+----+------------+------+-------+---------------------+---------------------+-----------+\n|  1 | test todo  |    0 | NULL  | 2024-10-02 20:21:16 | 2024-10-02 20:21:16 | NULL      |\n|  2 | test todo2 |    0 | NULL  | 2024-10-02 20:54:01 | 2024-10-02 20:54:01 | NULL      |\n|  3 | test todo3 |    0 | NULL  | 2024-10-02 20:54:04 | 2024-10-02 20:54:04 | NULL      |\n+----+------------+------+-------+---------------------+---------------------+-----------+\n3 rows in set (0.00 sec)\n```\n\n## すべてのデータを受け取る処理を作成する\n\nコツが掴めてきたので、今度はdb.goに直接定義していく。\n\ndb.go\n```go\n/*\nすべてのTodoをDBから取得する\n*/\nfunc SelectAll() []Todo {\n\tdb := CreateDBConnection(envVar)\n\tdefer db.Close()\n\n\tvar todo []Todo\n\terr := db.Select(&todo, \"SELECT * FROM todos\")\n\terrorpkg.CheckError(err)\n\n\treturn todo\n}\n```\n\n確認ようにmain.goに以下のコードを記載する\n\nmain.go\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"todoApp/db\"\n)\n\nfunc main() {\n\ttodos := db.SelectAll()\n\n\tfor _, t := range todos {\n\t\tfmt.Printf(\"Todo: %+v\\n\", t)\n\t}\n}\n```\n\n動作確認をする\n\n```sh\n$ go run main.go\nTodo: {ID:1 Content:test todo Done:false Until:<nil> CreatedAt:2024-10-02 20:21:16 +0900 JST UpdatedAt:2024-10-02 20:21:16 +0900 JST DeletedAt:<nil>}\nTodo: {ID:2 Content:test todo2 Done:false Until:<nil> CreatedAt:2024-10-02 20:54:01 +0900 JST UpdatedAt:2024-10-02 20:54:01 +0900 JST DeletedAt:<nil>}\nTodo: {ID:3 Content:test todo3 Done:false Until:<nil> CreatedAt:2024-10-02 20:54:04 +0900 JST UpdatedAt:2024-10-02 20:54:04 +0900 JST DeletedAt:<nil>}\n```",
      "body_updated_at": "2024-10-02"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-02",
      "body_markdown": "# Goのディレクトリ構成\n\nGoのディレクトリ構成について学んでみる\n\n公式のディレクトリ構成のドキュメント\nhttps://zenn.dev/furon/articles/2fad1ba7a82171\n\n作りながらディレクトリ分割する方法について\nhttps://zenn.dev/foxtail88/articles/824c5e8e0c6d82\n\nディレクトリ分割の参考\nhttps://qiita.com/Nori1983/items/7279a4f1f9c977336879\n\n## 選択\n\n公式のディレクトリ構成が良さそうなので、それを採用してみようかなと思う\n\n- cmdにエントリーポイント（プログラムが実行を開始する場所、プログラムの起動時に最初に実行される関数やコード）を配置\n- internalに他のもの（DB接続コードや、envの読み込み等のユーティリティ関数）を配置\n  \nといったようなざっくり理解で見切り発車する",
      "body_updated_at": "2024-10-04"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-04",
      "body_markdown": "# ディレクトリ構成の見直し\n\nまず現在の構成がどうなっているか\n\n```sh\n$ tree\n.\n├── db\n│   └── db.go\n├── env\n│   └── env.go\n├── error\n│   └── error.go\n├── go.mod\n├── go.sum\n├── main.go\n└── main_test.go\n\n4 directories, 7 files\n```\n\n## 見直し\n\n配置の見直しとしては次のようになると思う\n\ninternalに配置するもの\n- db.go\n- env.go\n- error.go\n\ncmdに配置するもの\n- main.go（まだ未実装だが、APIのエントリーポイントになる想定のため）\n\n## できるところまで変更する\n\nとりあえず、上記の個別のユーティリティ関数群はinternalに移せそうなので移しておく\n\nmain.goはまだ移動しない\nエントリーポイントが増えた、あるいはAPIserverとして完成したら移動しようと思う\n\n```sh\n$ tree\n.\n├── go.mod\n├── go.sum\n├── internal\n│   ├── db\n│   │   └── db.go\n│   ├── env\n│   │   └── env.go\n│   └── error\n│       └── error.go\n├── main.go\n└── main_test.go\n\n5 directories, 7 files\n```\n\n",
      "body_updated_at": "2024-10-04"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-04",
      "body_markdown": "# データをJSONにシリアライズ\n\nAPIとしてJSONデータで受け渡しを行うため、JSONへのシリアライズ処理を書く\n\n以下のコマンドでファイルを作成する\n```sh\nmkdir internal/json\ntouch internal/json/json.go\n```\n\nシリアライズ処理を書く\nテストのため、JSONファイルとして保存するコードとして書いている\n\n```go\npackage json\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"todoApp/internal/db\"\n)\n\nfunc SerializeTodos(todos []db.Todo) {\n\tfilename := \"test.json\"\n\terr := SaveToJson(filename, todos)\n\n\tif err != nil {\n\t\tfmt.Println(\"Error saving to JSON:\", err)\n\t} else {\n\t\tfmt.Println(\"Successfully saved to users.json\")\n\t}\n}\n\nfunc SaveToJson(filename string, data interface{}) error {\n\tfile, err := os.Create(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tencoder := json.NewEncoder(file)\n\tencoder.SetIndent(\"\", \" \")\n\terr = encoder.Encode(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n```\n\n## 動作確認\n\nmain.goに以下のコードを書いて、動作を確認する\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"todoApp/internal/db\"\n\t\"todoApp/internal/json\"\n)\n\nfunc main() {\n\ttodos := db.SelectAll()\n\n\tfor _, t := range todos {\n\t\tfmt.Printf(\"Todo: %+v\\n\", t)\n\t}\n\n\tfmt.Println(\"Serialize Todos data to json data\")\n\n\tjson.SerializeTodos(todos)\n}\n```\n\n実行する\n\n```sh\n$ % go run main.go\nTodo: {ID:1 Content:test todo Done:false Until:<nil> CreatedAt:2024-10-02 20:21:16 +0900 JST UpdatedAt:2024-10-02 20:21:16 +0900 JST DeletedAt:<nil>}\nTodo: {ID:2 Content:test todo2 Done:false Until:<nil> CreatedAt:2024-10-02 20:54:01 +0900 JST UpdatedAt:2024-10-02 20:54:01 +0900 JST DeletedAt:<nil>}\nTodo: {ID:3 Content:test todo3 Done:false Until:<nil> CreatedAt:2024-10-02 20:54:04 +0900 JST UpdatedAt:2024-10-02 20:54:04 +0900 JST DeletedAt:<nil>}\nSerialize Todos data to json data\nSuccessfully saved to users.json\n```\n\n\n保存されたファイルを確認\n\ntest.json\n```json\n[\n {\n  \"ID\": 1,\n  \"Content\": \"test todo\",\n  \"Done\": false,\n  \"Until\": null,\n  \"CreatedAt\": \"2024-10-02T20:21:16+09:00\",\n  \"UpdatedAt\": \"2024-10-02T20:21:16+09:00\",\n  \"DeletedAt\": null\n },\n {\n  \"ID\": 2,\n  \"Content\": \"test todo2\",\n  \"Done\": false,\n  \"Until\": null,\n  \"CreatedAt\": \"2024-10-02T20:54:01+09:00\",\n  \"UpdatedAt\": \"2024-10-02T20:54:01+09:00\",\n  \"DeletedAt\": null\n },\n {\n  \"ID\": 3,\n  \"Content\": \"test todo3\",\n  \"Done\": false,\n  \"Until\": null,\n  \"CreatedAt\": \"2024-10-02T20:54:04+09:00\",\n  \"UpdatedAt\": \"2024-10-02T20:54:04+09:00\",\n  \"DeletedAt\": null\n }\n]\n```",
      "body_updated_at": "2024-10-04"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-04",
      "body_markdown": "# 書きはしたけども\n\nJSONファイル保存コードを書いたけど、見直すと間違っていることに気づいた\nファイルに保存するのではなく、HTTPレスポンスとしてのJSONにしないといけない\n\nというわけで修正していく\n\nTodoは以下になる\n- [ ] サーバーを立てるコードを書く\n- [ ] JSONでレスポンスするコードを書く\n\n# サーバーコード\n\nサーバーを立てて、JSONでレスポンするコードを作成\n\nmain.go\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"todoApp/internal/db\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/todos\", todosHandler)\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nfunc todosHandler(w http.ResponseWriter, r *http.Request) {\n\ttodos := db.SelectAll()\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\terr := json.NewEncoder(w).Encode(todos)\n\tif err != nil {\n\t\thttp.Error(w, \"Failed to encode users\", http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n```\n\n## 動作確認\n\nまずサーバーを起動する\n\n```sh\n$ go run main.go\n# 待受状態になる\n```\n\nこの状態で、`http://localhost:8080/todos`にブラウザでアクセスする\n\n![](https://storage.googleapis.com/zenn-user-upload/cb75409c45c0-20241004.png)\n\n動作が確認できた\n\n---\n\n# 余談\n\nGoでサーバーを立ててJSONでレスポンスするコードのシンプルさに驚いた\nこんな簡単に実現できるようになってるんだね〜",
      "body_updated_at": "2024-10-05"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-04",
      "body_markdown": "# DB構成の見直し\n\nDeletedAtの扱いを参考書籍と同じようにしたが、今回の目的からするとこれは不要ではないかと考える\nTodoのデリートをするときは、単純にDBから消しただけで良いと考える\n\nというわけでDBの構成を変える\n\n- [ ] DeletedAtを削除する\n\n## カラムの削除\n\nmysqlクライアントからカラムの削除を実行\n\n```sql\nmysql> ALTER TABLE todos DROP COLUMN DeletedAt;\nQuery OK, 0 rows affected (0.02 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nmysql> select * from todos;\n+----+------------+------+-------+---------------------+---------------------+\n| ID | Content    | Done | Until | CreatedAt           | UpdatedAt           |\n+----+------------+------+-------+---------------------+---------------------+\n|  1 | test todo  |    0 | NULL  | 2024-10-02 20:21:16 | 2024-10-02 20:21:16 |\n|  2 | test todo2 |    0 | NULL  | 2024-10-02 20:54:01 | 2024-10-02 20:54:01 |\n|  3 | test todo3 |    0 | NULL  | 2024-10-02 20:54:04 | 2024-10-02 20:54:04 |\n+----+------------+------+-------+---------------------+---------------------+\n3 rows in set (0.00 sec)\n```\n\n## 構造体も修正\n\n構造体にもカラムの定義があるため、削除する\n\n```go\ntype Todo struct {\n\tID        int        `db:\"ID\"`\n\tContent   string     `db:\"Content\"`\n\tDone      bool       `db:\"Done\"`\n\tUntil     *time.Time `db:\"Until\"`\n\tCreatedAt time.Time  `db:\"CreatedAt\"`\n\tUpdatedAt time.Time  `db:\"UpdatedAt\"`\n\t// ここを削除する\n\t// DeletedAt *time.Time `db:\"DeletedAt\"`\n}\n```",
      "body_updated_at": "2024-10-04"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-05",
      "body_markdown": "# DBへの登録処理を書く（前編）\n\nDBからの全データ取得はかけたので、今度はリクエストされたデータを受け取ってDBへ登録する処理を書く\n\n## とりあえず動く物を作成する\n\nいつもやっている以下の方針に従い、とりあえず動く物を作成する\n\n- まず動く物を書く\n- 動くものに変更を加えて、動作を確かめながら作成する\n- 動作がおかしいようであれば動くように直す\n\n動作確認用のため、今回使用するデータ（構造体）はダミー用のものとなる\nダミーデータで一旦動作を確認し、その後本番用のデータ（構造体）に差し替えていく方法を取りたい\n\n## エンドポイント\n\n- `/register`をエンドポイントとする\n- リクエストはJSONを受け付ける\n- リクエストJSONの中身は次のような感じ\n```json\n{\n    \"Content\": \"content string\"\n}\n```\n\n## テストコード\n\nTDD式に、先にテストから書く\n\n```go\nfunc TestRegisterHandler(t *testing.T) {\n\t// リクエスト用のJSONデータの作成\n\treqBody := User{\n\t\tID:   1,\n\t\tName: \"John\",\n\t}\n\tjsonData, err := json.Marshal(reqBody)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to marshal request: %v\", err)\n\t}\n\n\t// JSONリクエストの作成\n\treq, err := http.NewRequest(\"POST\", \"/register\", bytes.NewBuffer(jsonData))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create request: %v\", err)\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\t// レスポンス記録のためのレコーダーを用意\n\trr := httptest.NewRecorder()\n\n\t// ハンドラーの呼び出し\n\thandler := http.HandlerFunc(registerHandler)\n\thandler.ServeHTTP(rr, req)\n\n\t// ステータスコードが200かの確認\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Errorf(\"Handler returned wrong status code: got %v want %v\", status, http.StatusOK)\n\t}\n\n\t// レスポンスの内容を確認\n\tvar resBody Response\n\tif err := json.NewDecoder(rr.Body).Decode(&resBody); err != nil {\n\t\tt.Fatalf(\"Failed to decode response: %v\", err)\n\t}\n\n\texpectedMessage := \"Hello, John\"\n\tif resBody.Message != expectedMessage {\n\t\tt.Errorf(\"Handler returned unexpected body: got %v want %v\", resBody.Message, expectedMessage)\n\t}\n}\n```\n\n（参考資料）\njson.Marshal\nhttps://zenn.dev/satumahayato010/articles/ae2484d53c6a11\n\n## ハンドラー関数を書く\n\nテストコードで書いた`RegisterHandler`は存在しないため、その関数を実装していく\n\n```go\n\ntype User struct {\n\tID   int    `db:\"id\"`\n\tName string `db:\"name\"`\n}\n\ntype Response struct {\n\tMessage string `json:\"message\"`\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/todos\", todosHandler)\n\thttp.HandleFunc(\"/register\", registerHandler)\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nfunc registerHandler(w http.ResponseWriter, r *http.Request) {\n\tvar req User\n\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tresponse := Response{\n\t\tMessage: \"Hello, \" + req.Name,\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(response)\n\n}\n```",
      "body_updated_at": "2024-10-06"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-06",
      "body_markdown": "# DBへの登録処理を書く（中編）\n\nさて、動くものは作成できたので、本番用のデータに差し替えて動作を確認していこう\n\n## クライアントから受け取るデータ\n\nクライアントから受け取るデータを整理する\n\nサーバー側で扱うデータは以下の形になっているが、DB側で自動付与するカラムもあるため、一対一対応はしない\n\n```sql\nCREATE TABLE todos (\n    ID INT AUTO_INCREMENT PRIMARY KEY,\n    Content VARCHAR(255) NOT NULL,\n    Done TINYINT(1) NOT NULL DEFAULT 0,\n    Until DATETIME,\n    CreatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    UpdatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n);\n```\n\nさて、クライアントからは何を渡せばいいだろうか？\n\nDB側で自動でデータを登録するカラムは、\n- ID\n- CreatedAt\n- UpdatedAt\n\nの3つ\n\n残った3つの中でクライアントから渡すべきものはなんだろうか\n\nまずContentは必須。Todoの内容を示す文字列のため、クライアントから渡すべき情報だから\n\nDoneはどうだろうか。こちらは最初から1(True)で埋まることはないので、0梅で正しいとなる。そうなると、この項目もクライアントから渡す必要はない\n\nUntilはどうだろうか。「いつまでに終わらせる」といった情報は、一意に定まる値ではないため（デフォルト値は今回無いので）、クライアントから明示的に渡す必要のある値\n\n以上の整理より、\n- Content\n- Until\n\n以上の2つを渡す必要があるということになる\n\n## データ構造の整理\n\nさて、以上の2つを渡すにあたって、構造体を定義しよう\n\n必要なものは2つある\n- リクエスト時に渡すJSONに紐づく構造体\n- レスポンス時に返すJSONに紐づく構造体\n\n急に出てきた、レスポンス時に返すJSONとはなんだろうか？\nリクエストからデータを受け取ってデータを登録したあと、結果が成功か失敗かを情報をしてクライアントに返す必要があるので、そのためのJSON定義\n\nというわけで2つ定義していく\n\nmain.go\n```go\n// 登録用リクエストの構造体\ntype RegisterRequest struct {\n\tContent string    `db:\"Content\"`\n\tUntil   time.Time `db:\"Until\"`\n}\n\n// 登録結果のレスポンス用の構造体\ntype Response struct {\n\tResult string `json:\"result\"`\n}\n```\n\nレスポンス用の構造体は、他のエンドポイントでも共通で使われる可能性があるため、`Response`という抽象的な名前にした\n実装の中で変更がある場合に、名前を変えていく方向で行きたい（YAGNIの法則の考え方）\n\n(参考）\n日付フォーマットが`2006-01-02`となっている理由\nhttps://blog.toshimaru.net/go-time-format/\n\n",
      "body_updated_at": "2024-10-06"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-06",
      "body_markdown": "# 構造体を別のファイルに切り出す\n\n構造体が増えてきたため、個別のファイルに切り出して管理する\n\n`internal`ディレクトに`models`というディレクトリを作成し、構造体を保存する`todo.go`というファイルを作成\n\n```sh\n$ tree\n.\n├── go.mod\n├── go.sum\n├── internal\n│   ├── db\n│   │   └── db.go\n│   ├── env\n│   │   └── env.go\n│   ├── error\n│   │   └── error.go\n│   └── models\n│       └── todo.go\n├── main.go\n├── main_test.go\n└── test.json\n\n6 directories, 9 files\n\n```\n\n構造体をこちらに移していく\n\ninternal/models/todo.go\n\n```go\npackage models\n\nimport \"time\"\n\ntype RegisterRequest struct {\n\tContent string    `db:\"Content\"`\n\tUntil   time.Time `db:\"Until\"`\n}\n\ntype Response struct {\n\tResult string `json:\"result\"`\n}\n\ntype Todo struct {\n\tID        int        `db:\"ID\"`\n\tContent   string     `db:\"Content\"`\n\tDone      bool       `db:\"Done\"`\n\tUntil     *time.Time `db:\"Until\"`\n\tCreatedAt time.Time  `db:\"CreatedAt\"`\n\tUpdatedAt time.Time  `db:\"UpdatedAt\"`\n}\n\n// 動作test用の構造体\ntype User struct {\n\tID   int    `db:\"id\"`\n\tName string `db:\"name\"`\n}\n```\n\n## 構造体呼び出しを変更する\n\n構造体の呼び出しを、以上のファイルから呼び出す形に変更する必要がある\n\nやることは以下の2点\n\n- importを書く。あるいはimport先を変更する\n- `models.Struct`といった記載に変更する\n\n一例として、db.goの関数を挙げているが、他の関数も同様に変更している\n```go\n/*\n指定したIDのTodoをDBから取得する\n*/\n// 返り値の型の呼び出しが変わった\nfunc SelectById(id int) models.Todo {\n\tdb := CreateDBConnection(envVar)\n\tdefer db.Close()\n\n\t// 変数宣言も同様に型の呼び出しを変えた\n\tvar todo models.Todo\n\terr := db.Get(&todo, \"SELECT * FROM todos WHERE id=?\", id)\n\terrorpkg.CheckError(err)\n\n\treturn todo\n}\n```\n",
      "body_updated_at": "2024-10-06"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-06",
      "body_markdown": "# DBへの登録処理を書く（後編）\n\nDB登録コードの変更で残った部分を作成\n\n## テストコード\n\nまずテストコードを変更する\n\n```go\nfunc TestRegisterHandler(t *testing.T) {\n\t// リクエスト用のJSONデータの作成\n\tuntilTime := \"2024-12-31\"\n\tuntilDate, err := time.Parse(\"2006-01-02\", untilTime)\n\n\treqBody := models.RegisterRequest{\n\t\tContent: \"todo test content\",\n\t\tUntil:   untilDate,\n\t}\n\n\tjsonData, err := json.Marshal(reqBody)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to marshal request: %v\", err)\n\t}\n\n\t// JSONリクエストの作成\n\treq, err := http.NewRequest(\"POST\", \"/register\", bytes.NewBuffer(jsonData))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create request: %v\", err)\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\t// レスポンス記録のためのレコーダーを用意\n\trr := httptest.NewRecorder()\n\n\t// ハンドラーの呼び出し\n\thandler := http.HandlerFunc(registerHandler)\n\thandler.ServeHTTP(rr, req)\n\n\t// ステータスコードが200かの確認\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Errorf(\"Handler returned wrong status code: got %v want %v\", status, http.StatusOK)\n\t}\n\n\t// レスポンスの内容を確認\n\tvar resBody models.Response\n\tif err := json.NewDecoder(rr.Body).Decode(&resBody); err != nil {\n\t\tt.Fatalf(\"Failed to decode response: %v\", err)\n\t}\n\n\texpectedMessage := \"SUCCESS\"\n\tif resBody.Result != expectedMessage {\n\t\tt.Errorf(\"Handler returned unexpected body: got %v want %v\", resBody.Result, expectedMessage)\n\t}\n}\n```\n\n## ハンドラー関数(main.go)\n\n次に、それにテストを通るようにハンドラー関数を変更する\n\n```go\nfunc registerHandler(w http.ResponseWriter, r *http.Request) {\n\tvar req models.RegisterRequest\n\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// 成功の場合のResponseデータを作成\n\tresponse := models.Response{\n\t\tResult: \"SUCCESS\",\n\t}\n\n\t// DBへの登録処理を行う\n\t_, err := db.Insert(req)\n\t// DB登録処理が失敗なら、エラーメッセージを格納したResponseデータに変更\n\tif err != nil {\n\t\tresponse = models.Response{\n\t\t\tResult: \"Data register error.\",\n\t\t}\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(response)\n\n}\n```\n\n## db.go\n\nDBへのインサート処理を追加\nなお、失敗したかどうかを判定する必要があるため、判定結果を返すようにしている\n\n```go\n/*\nデータをDBにINSERTする\n*/\nfunc Insert(data models.RegisterRequest) (int64, error) {\n\tdb := CreateDBConnection(envVar)\n\tdefer db.Close()\n\n\tresult, err := db.Exec(\"INSERT INTO todos (Content, Until) VALUES (?, ?)\", data.Content, data.Until)\n\terrorpkg.CheckError(err)\n\n\tlastInsertID, err := result.LastInsertId()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn lastInsertID, err\n}\n```",
      "body_updated_at": "2024-10-06"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-07",
      "body_markdown": "# コメントの追加\n\nだんだん複雑になってきたので、コメントを追加（ほぼ自分用）\n\nコメントを追加する効用として自分が感じているものは\n\n- あとで見返した時、関数の細かい動作を忘れていることがあるので(というよりオールウェイズ)、コメントがあったほうが変更するときにスムーズになる\n- VSCodeの拡張で関数にマウスホバーすると関数の情報が出るが、そのときに簡単な関数の概略が分かって良い\n- Document生成ツールなどを使うときに、自動でコメントが説明として表示されるのが便利。あとでコメント追加しようとするとコードすべて読まないといけないので、わかるうちにコメント書いておく考え。\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"todoApp/internal/db\"\n\t\"todoApp/internal/models\"\n)\n\nfunc main() {\n\t// リスト(todo)の一覧を取得するハンドラのバインド\n\thttp.HandleFunc(\"/todos\", todosHandler)\n\t// リクエストしたデータを登録するハンドラのバインド\n\thttp.HandleFunc(\"/register\", registerHandler)\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\n/*\nリクエストに含まれるデータをDBに登録するハンドラ\n*/\nfunc registerHandler(w http.ResponseWriter, r *http.Request) {\n\tvar req models.RegisterRequest\n\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// 成功の場合のResponseデータを作成\n\tresponse := models.Response{\n\t\tResult: \"SUCCESS\",\n\t}\n\n\t// DBへの登録処理を行う\n\t_, err := db.Insert(req)\n\t// DB登録処理が失敗なら、エラーメッセージを格納したResponseデータに変更\n\tif err != nil {\n\t\tresponse = models.Response{\n\t\t\tResult: \"Data register error.\",\n\t\t}\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(response)\n\n}\n\n/*\nDBからTodoの全リストを取得して、レスポンスするハンドラ\n*/\nfunc todosHandler(w http.ResponseWriter, r *http.Request) {\n\ttodos := db.SelectAll()\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\terr := json.NewEncoder(w).Encode(todos)\n\tif err != nil {\n\t\thttp.Error(w, \"Filed to encode users\", http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n\n```",
      "body_updated_at": "2024-10-07"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-07",
      "body_markdown": "# 登録データの削除\n\nAPIでDBデータのDelete処理を実装する。\n\n## 仕様\n\n- JSONでDelete対象のデータのIDをリクエストする\n- エンドポイントは`/delete`\n- レスポンスはエラーか成功かを示すメッセージがJSONで返ってくる\n\n## 型定義\n\n`internal/models/todo.go`にリクエスト用の型定義を追加する。\nレスポンス用の型定義はすでに定義したものを使い回すので、ここでは定義不要。\n\n```go\ntype DeleteRequest struct {\n\tID int `db:\"ID\"`\n}\n```\n\n## テストコードを先に書く\n\nテストコードから書いていく。\n登録時に使ったものを使いまわして変更する感じで作る。\n\n```go\nfunc TestDeleteHandler(t *testing.T) {\n\treqBody := models.DeleteRequest{\n\t\tID: 1,\n\t}\n\n\tjsonData, err := json.Marshal((reqBody))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to marshal request: %v\", err)\n\t}\n\n\treq, err := http.NewRequest(\"POST\", \"/delete\", bytes.NewBuffer(jsonData))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to delete request: %v\", err)\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\trr := httptest.NewRecorder()\n\n\thandler := http.HandlerFunc(deleteHandler)\n\thandler.ServeHTTP(rr, req)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Errorf(\"Handler returned wrong status code: got %v want %v\", status, http.StatusOK)\n\t}\n\n\tvar resBody models.Response\n\tif err := json.NewDecoder(rr.Body).Decode(&resBody); err != nil {\n\t\tt.Fatalf(\"Failed to decode response: %v\", err)\n\t}\n\n\texpectedMessage := \"SUCCESS\"\n\tif resBody.Result != expectedMessage {\n\t\tt.Errorf(\"Handler returned unexpected body: got %v want %v\", resBody.Result, expectedMessage)\n\t}\n}\n```\n\n入出力が決まっているから、基本的に変えなくていいのは利点。\n変わっているのは\n- 入力がDeleteRequest型のJSONデータ\n  \nのみだと思う。\n\n## ハンドラ関数を書く\n\nハンドラ関数を書く\n\nmain.go\n```go\n/*\nリクエストで指定したIDのデータを削除するハンドラ\n*/\nfunc deleteHandler(w http.ResponseWriter, r *http.Request) {\n\tvar req models.DeleteRequest\n\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tresponse := models.Response{\n\t\tResult: \"SUCCESS\",\n\t}\n\n\t// DBの削除処理を行う\n\t_, err := db.Delete(req)\n\n\tif err != nil {\n\t\tresponse = models.Response{\n\t\t\tResult: \"Data delete error.\",\n\t\t}\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(response)\n}\n```\n\n## ハンドラのバインドを書く\n\n作ったDeleteHanlderのバインド処理を書く\n\nmain.go\n```go\nfunc main() {\n\t// リスト(todo)の一覧を取得するハンドラのバインド\n\thttp.HandleFunc(\"/todos\", todosHandler)\n\t// リクエストしたデータを登録するハンドラのバインド\n\thttp.HandleFunc(\"/register\", registerHandler)\n\t// リクエストしたデータを削除するハンドラのバインド\n\thttp.HandleFunc(\"/delete\", deleteHandler)\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\n```\n\n## Deleteのロジックを書く\n\nDeleteのロジックコードを書く\n\ndb.go\n```go\n/*\n指定されたIDのデータを削除する\n*/\nfunc Delete(data models.DeleteRequest) (int64, error) {\n\tdb := CreateDBConnection(envVar)\n\tdefer db.Close()\n\n\t// クエリ実行\n\tresult, err := db.Exec(\"DELETE FROM todos WHERE ID = ?\", data.ID)\n\terrorpkg.CheckError(err)\n\n\t// 実際に削除した行数を取得する\n\trowsAffected, err := result.RowsAffected()\n\t// 削除行数取得に失敗した場合のエラーを返す\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// 削除した行数が0なら、エラーとして返す\n\tif rowsAffected == 0 {\n\t\treturn 0, err\n\t}\n\n\t// 削除した行数を返却する\n\treturn rowsAffected, err\n}\n```\n\nテストコードを動かし、mysqlへ接続して、ちゃんと削除されたかを確認する。\n確認方法は他の箇所で記載しているため、ここでは省略する。",
      "body_updated_at": "2024-10-09"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-07",
      "body_markdown": "# リファクタリング\n\nInsertとDeleteでのリターンがタプルとなっていて、一見複雑なので、シンプルな形に変更する。\n単純にerrorを返したら良さそうに思うので。\n\n## Deleteの変更\n\n書いたばかりのコードを変更するのが容易なため、Deleteから先に変更していく。\n\ndb.go\n```go\n/*\n指定されたIDのデータを削除する\n*/\nfunc Delete(data models.DeleteRequest) error {\n\tdb := CreateDBConnection(envVar)\n\tdefer db.Close()\n\n\t// クエリ実行\n\tresult, err := db.Exec(\"DELETE FROM todos WHERE ID = ?\", data.ID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to execute delete: %v\", err)\n\t}\n\n\t// 実際に削除した行数を取得する\n\trowsAffected, err := result.RowsAffected()\n\t// 削除行数取得に失敗した場合のエラーを返す\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to retrieve affected rows: %v\", err)\n\t}\n\n\t// 削除した行数が0ならエラーを返す\n\tif rowsAffected == 0 {\n\t\treturn fmt.Errorf(\"no rows deleted, ID %d not found\", data.ID)\n\t}\n\n\t// 正常終了のため、nilを返す\n\treturn nil\n}\n```\n\nハンドラ側も変更する。\n\nmain.go\n\n```go\n/*\nリクエストで指定したIDのデータを削除するハンドラ\n*/\nfunc deleteHandler(w http.ResponseWriter, r *http.Request) {\n\tvar req models.DeleteRequest\n\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tresponse := models.Response{\n\t\tResult: \"SUCCESS\",\n\t}\n\n\t// DBの削除処理を行う\n\terr := db.Delete(req)\n\n\tif err != nil {\n\t\tresponse = models.Response{\n\t\t\tResult: \"Data delete error.\",\n\t\t}\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(response)\n}\n```\n\n処理ができたので、テストコードを起動してテストする。\n\n![](https://storage.googleapis.com/zenn-user-upload/5c57289afc39-20241007.png)\n\nめっちゃエラーおきた。\n\n## エラーの解消に向けて\n\nどうやら、テストコードではIDが1のデータを必ず削除しているが、すでにデータを消しているため、ID\n1が存在していないのが問題らしい。\n\nテストコードにID1のデータを登録する処理を追加することで、テストが通るようにする。\n\nテスト用にIDを指定してインサートするコードを追加する\n\n```go\n/*\n指定したIDのデータをDBにINSERTする\n*/\nfunc InsertById(id int, data models.RegisterRequest) (int64, error) {\n\tdb := CreateDBConnection(envVar)\n\tdefer db.Close()\n\n\tresult, err := db.Exec(\"INSERT INTO todos (ID, Content, Until) VALUES (?, ?, ?)\", id, data.Content, data.Until)\n\terrorpkg.CheckError(err)\n\n\tlastInsertID, err := result.LastInsertId()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn lastInsertID, err\n}\n```\n\nテストコードを変更する。\n\n```go\nfunc TestDeleteHandler(t *testing.T) {\n\t// deleteテスト用のデータを作成\n\tuntilTime := \"2024-12-31\"\n\tuntilDate, err := time.Parse(\"2006-01-02\", untilTime)\n\terrorpkg.CheckError(err)\n\n\ttestData := models.RegisterRequest{\n\t\tContent: \"todo test content\",\n\t\tUntil:   untilDate,\n\t}\n\n\t// testデータのインサート\n\tdb.InsertById(1, testData)\n\n\t// delete用のリクエストデータを作成\n\treqBody := models.DeleteRequest{\n\t\tID: 1,\n\t}\n\n\tjsonData, err := json.Marshal((reqBody))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to marshal request: %v\", err)\n\t}\n\n\treq, err := http.NewRequest(\"POST\", \"/delete\", bytes.NewBuffer(jsonData))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to delete request: %v\", err)\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\trr := httptest.NewRecorder()\n\n\thandler := http.HandlerFunc(deleteHandler)\n\thandler.ServeHTTP(rr, req)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Errorf(\"Handler returned wrong status code: got %v want %v\", status, http.StatusOK)\n\t}\n\n\tvar resBody models.Response\n\tif err := json.NewDecoder(rr.Body).Decode(&resBody); err != nil {\n\t\tt.Fatalf(\"Failed to decode response: %v\", err)\n\t}\n\n\texpectedMessage := \"SUCCESS\"\n\tif resBody.Result != expectedMessage {\n\t\tt.Errorf(\"Handler returned unexpected body: got %v want %v\", resBody.Result, expectedMessage)\n\t}\n}\n```\n\nテストコードが改修できたので、グリーンバーになることを確認する。\n\n![](https://storage.googleapis.com/zenn-user-upload/1dff7288dbbe-20241007.png)\n",
      "body_updated_at": "2024-10-07"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-07",
      "body_markdown": "# リファクリング2\n\nこんどはInsert関数を変更する。\n\nDeleteのテスト用に追加したInsetById関数も同様に変更していく。\n\n## Insertを変更する\n\nまず呼び出し側のハンドラ関数から変更する。\n\n```go\n/*\nリクエストに含まれるデータをDBに登録するハンドラ\n*/\nfunc registerHandler(w http.ResponseWriter, r *http.Request) {\n\tvar req models.RegisterRequest\n\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// 成功の場合のResponseデータを作成\n\tresponse := models.Response{\n\t\tResult: \"SUCCESS\",\n\t}\n\n\t// DBへの登録処理を行う\n\terr := db.Insert(req)\n\t// DB登録処理が失敗なら、エラーメッセージを格納したResponseデータに変更\n\tif err != nil {\n\t\tresponse = models.Response{\n\t\t\tResult: \"Data register error.\",\n\t\t}\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(response)\n\n}\n```\n\n## 関数側も変更する\n\ndb.go\n\n```go\n/*\nデータをDBにINSERTする\n*/\nfunc Insert(data models.RegisterRequest) error {\n\tdb := CreateDBConnection(envVar)\n\tdefer db.Close()\n\n\t_, err := db.Exec(\"INSERT INTO todos (Content, Until) VALUES (?, ?)\", data.Content, data.Until)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to execute insert: %v\", err)\n\t}\n\n\treturn nil\n}\n```\n\nかなりシンプルになった。\n\n同様にInsertById関数も変更する。\n\n```go\n/*\n指定したIDのデータをDBにINSERTする\n*/\nfunc InsertById(id int, data models.RegisterRequest) error {\n\tdb := CreateDBConnection(envVar)\n\tdefer db.Close()\n\n\t_, err := db.Exec(\"INSERT INTO todos (ID, Content, Until) VALUES (?, ?, ?)\", id, data.Content, data.Until)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to execute insert: %v\", err)\n\t}\n\n\treturn nil\n}\n```\n\n",
      "body_updated_at": "2024-10-07"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-07",
      "body_markdown": "# APIの完成\n\nこれでAPIのロジックは完成した。\n\n次はフロント部分を作り込んでいく。"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-08",
      "body_markdown": "# フロントの仕様\n\nフロントの仕様をどうするか。\n\nバックエンドをAPIとして完全に独立して実装したため、フロントはAPIをフェッチする形で実装する必要がある。\n\nとりあえず方針としては以下のようにしたい。\n\n- スタティックなhtmlを返すエンドポイントを作成し、画面を返す。\n- 画面からJavaScriptを用いて、データをフェッチしてくる。\n"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-08",
      "body_markdown": "# ファイルの準備\n\nまずhtmlファイルの準備から。\n\n```sh\nmkdir static\ntouch static/index.html\ntouch static/script.js\n```\n\n上記の操作の結果、以下のディレクトリ構成となる。\n\n```sh\n.\n├── README.md\n└── todo-app-go\n    ├── go.mod\n    ├── go.sum\n    ├── internal\n    │   ├── db\n    │   │   └── db.go\n    │   ├── env\n    │   │   └── env.go\n    │   ├── error\n    │   │   └── error.go\n    │   └── models\n    │       └── todo.go\n    ├── main.go\n    ├── main_test.go\n    └── static\n        ├── index.html\n        └── script.js\n\n```"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-08",
      "body_markdown": "# フロントの準備をする\n\nまず、動作確認のため、簡単なテスト用のコードを記載し、動作を確認する。\n\nindex.html\n```html\n<!DOCTYPE html>\n<html lang=\"ja\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Todo App</title>\n</head>\n<body>\n    <h1>Welcome to Todo App!</h1>\n    <p>Hello html!</p>\n</body>\n</html>\n```\n\nこのhtmlをレスポンスできるように、main.goにエンドポイントを追加する。\n\nmain.go\n\n```go\nfunc main() {\n\thttp.HandleFunc(\"/todos\", todosHandler)\n\thttp.HandleFunc(\"/register\", registerHandler)\n\n\t// 画面を返すエンドポイント\n\tfs := http.FileServer(http.Dir(\"./static\"))\n\thttp.Handle(\"/\", fs)\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```\n\nこれで簡単なhtml画面を返せるようになった。\n\n## 動作確認\n\n動作確認をする。\nまず以下のコマンドでサーバーを立ち上げる。\n\n```go\ngo run main.go\n# これでサーバーが立ち上がり、リッスン状態になる\n```\n\n次に、ブラウザで`localhost:8080`と入力し、アクセスする。\n\n次のような画面が表示されたら成功。\n![](https://storage.googleapis.com/zenn-user-upload/830c7c0ed83d-20241008.png)",
      "body_updated_at": "2024-10-08"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-08",
      "body_markdown": "# JavaScriptを追加する\n\nJavaScriptを動かせるようにする。\n例のごとく、まずは簡単なコードを動かせる状態にして、動作を確認するところから。\n\n## JavaScriptコードを書く\n\n`static/script.js`に以下のようなコードを書く。\n何をしているかは後ほど説明する。\n\n```js\nwindow.onload = function() {\n    document.getElementById('message').textContent = 'Hello from JavaScript!';\n};\n```\n\n## htmlコードを変更する\n\nhtmlコードでJavaScriptを実行するためのコードを書く。\n\n```html\n<!DOCTYPE html>\n<html lang=\"ja\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Todo App</title>\n    <!-- JavaScriptファイルを読み込み -->\n    <script src=\"script.js\" defer></script>\n</head>\n<body>\n    <h1>Welcome to Todo App!</h1>\n    <!-- JavaScriptによる書き換えを行うための要素を追加 -->\n    <p id=\"message\">This message will be replaced by JavaScript.</p>\n</body>\n</html>\n```\n\n## 動作確認\n\nhtmlのときと同様に、ブラウザから`localhost:8080`にアクセスする。\n\n![](https://storage.googleapis.com/zenn-user-upload/7aa4d8f6cca2-20241008.png)\n\nJavaScriptが何をしているかというと、\n- index.htmlにある、pタグのidがmessageになっているDOM要素を取得\n- 取得したDOM要素のtextContentに文字列を代入することで置き換える\n\nといった動作を行っている。\n\nなお、DOMについてはフロントをいじると必ず出くわす概念のため、把握しておく必要がある。\nDOMがなにかといったところは下記を参照してほしい。\n\nhttps://zenn.dev/nako_110/articles/db546fa1563547\nhttps://zenn.dev/nash/articles/4490d73b406561\nhttps://zenn.dev/nameless_sn/articles/javascript_dom_tutorial\n\nDOMに関しては調べるといくらでも良質な記事や動画が出てくるので、わかりやすいものを探してそちらを見たほうが理解は早いかも。",
      "body_updated_at": "2024-10-08"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-08",
      "body_markdown": "# フロントに必要な要素を配置する\n\nフロントで使う画面の要素を配置していく。\n動作の実装等は後ほど行う。\n\n- Todoを追加するためのinputと送信ボタン\n- 現在のTodo一覧を表示する欄\n- Todo一覧では、完了ボタンと削除ボタンを配置する\n\nここまで書いて、完了ボタンの動作をAPIに実装していなかったことを思い出したので、次のセクションで実装する。\n\n# Todo追加用のinputと送信ボタンの設置\n\n```html\n<!DOCTYPE html>\n<html lang=\"ja\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Todo App</title>\n    <script src=\"script.js\" defer></script>\n</head>\n<body>\n    <h1>Welcome to Todo App!</h1>\n    <div>\n        <input placeholder=\"Input new todo\"/>\n        <button>送信</button>\n    </div>\n</body>\n</html>\n```\n\n![](https://storage.googleapis.com/zenn-user-upload/c430a2cd8f29-20241008.png)\n\n# Todo表示欄(一覧)\n\n```html\n<!DOCTYPE html>\n<html lang=\"ja\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Todo App</title>\n    <script src=\"script.js\" defer></script>\n</head>\n<body>\n    <h1>Welcome to Todo App!</h1>\n    <div>\n        <input placeholder=\"Input new todo\"/>\n        <button>送信</button>\n    </div>\n    <div id=\"todoList\">\n    </div>\n</body>\n</html>\n```\n\nこれは今の段階では空の要素のみを配置しているため画面には何も表示されないことに注意する。\n\n残りの要素はJavaScriptの処理で設置していくため、画面の要素配置はここまでで終了となる。\n",
      "body_updated_at": "2024-10-08"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-09",
      "body_markdown": "# TodoをDoneにした場合の処理を書く\n\n不足していたAPIの処理を書く。\n具体的に言うと、TodoをDoneにした場合の処理を書く。\n\nテーブル構成忘れているのと、ログが長くなって参照しづらいため、テーブル構成を再掲。\n\n```mermaid\nerDiagram\n\tTODOS {\n\t\tID INT PK \"AUTO_INCREMENT\"\n\t\tContent VARCHAR  \"NOT NULL\"\n\t\tDone BOOLEAN  \"TINYINT(1)\"\n\t\tUntile DATETIME\n\t\tCreatedAt DATETIME  \"DEFAULT CURRENT_TIMESTAMP\"\n\t\tUpdatedAt DATETIME \"DEFAULT CURRENT_TIMESTAMP ON UPDATE\"\n\t\tDeletedAt DATETIME\n\t}\n```\n\nDoneボタンが押された場合に、紐づくidのデータのDoneをtrueに更新する処理を書いていく。\n\n## エンドポイント\n\nエンドポイントは`/update`とし、idが入ったJSONをリクエストする形で進めたい。\n\n## テストコード\n\nまずテストコードを書く。\n\n```go\n/*\nupdateエンドポイントのテストコード\n*/\nfunc TestUpdateHandler(t *testing.T) {\n\t// deleteテスト用のデータを作成\n\tuntilTime := \"2024-12-31\"\n\tuntilDate, err := time.Parse(\"2006-01-02\", untilTime)\n\terrorpkg.CheckError(err)\n\n\ttestData := models.RegisterRequest{\n\t\tContent: \"todo test content\",\n\t\tUntil:   untilDate,\n\t}\n\n\t// testデータのインサート\n\terr = db.InsertById(1, testData)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to insert query: %v\", err)\n\t}\n\n\t// update用のリクエストデータを作成\n\treqBody := models.UpdateRequest{\n\t\tID: 1,\n\t}\n\n\tjsonData, err := json.Marshal((reqBody))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to marshal request: %v\", err)\n\t}\n\n\treq, err := http.NewRequest(\"POST\", \"/update\", bytes.NewBuffer(jsonData))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to update request: %v\", err)\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\trr := httptest.NewRecorder()\n\n\thandler := http.HandlerFunc(updateHandler)\n\thandler.ServeHTTP(rr, req)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Errorf(\"Handler returned wrong status code: got %v want %v\", status, http.StatusOK)\n\t}\n\n\tvar resBody models.Response\n\tif err := json.NewDecoder(rr.Body).Decode(&resBody); err != nil {\n\t\tt.Fatalf(\"Failed to decode response: %v\", err)\n\t}\n\n\texpectedMessage := \"SUCCESS\"\n\tif resBody.Result != expectedMessage {\n\t\tt.Errorf(\"Handler returned unexpected body: got %v want %v\", resBody.Result, expectedMessage)\n\t}\n\n\t// テストデータ削除用にデータを作成\n\tdeleteId := models.DeleteRequest{\n\t\tID: 1,\n\t}\n\terr = db.Delete(deleteId)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to delete test data: %v\", err)\n\t}\n\n}\n```\n\n## ハンドラの作成\n\nupdateリクエストを受け付けるハンドラを作成\n\nmain.go\n\n```go\n/*\nリクエストで指定したIDのデータの状態を更新するハンドラ\n*/\nfunc updateHandler(w http.ResponseWriter, r *http.Request) {\n\tvar req models.UpdateRequest\n\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tresponse := models.Response{\n\t\tResult: \"SUCCESS\",\n\t}\n\n\t// データの更新を行う\n\terr := db.Update(req)\n\n\tif err != nil {\n\t\tresponse = models.Response{\n\t\t\tResult: \"Data update error.\",\n\t\t}\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(response)\n}\n```\n\nバインドも追加する\n\nmain.go\n\n```go\nfunc main() {\n\t// リスト(todo)の一覧を取得するハンドラのバインド\n\thttp.HandleFunc(\"/todos\", todosHandler)\n\t// リクエストしたデータを登録するハンドラのバインド\n\thttp.HandleFunc(\"/register\", registerHandler)\n\t// リクエストしたデータを削除するハンドラのバインド\n\thttp.HandleFunc(\"/delete\", deleteHandler)\n\t// リクエストしたデータを更新するハンドラのバインド\n\thttp.HandleFunc(\"/update\", updateHandler)\n\n\t// 画面を返すエンドポイント\n\tfs := http.FileServer(http.Dir(\"./static\"))\n\thttp.Handle(\"/\", fs)\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```\n\n## DBとの処理を書く\n\nDBと実際に処理するUpdate関数を書く\n\ndb.go\n\n```go\n/*\n指定したIDのデータを更新する。\n*/\nfunc Update(data models.UpdateRequest) error {\n\tdb := CreateDBConnection(envVar)\n\tdefer db.Close()\n\n\t// クエリ実行\n\tresult, err := db.Exec(\"UPDATE todos SET Done = IF(Done = 1, 0, 1) WHERE id = ?\", data.ID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to execute update: %v\", err)\n\t}\n\n\t// 実際に更新した行数を取得する\n\trowsAffected, err := result.RowsAffected()\n\t// 更新した行数取得に失敗した場合のエラーを返す\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to retrieve affected rows: %v\", err)\n\t}\n\n\t// 更新した行数が0ならエラーを返す\n\tif rowsAffected == 0 {\n\t\treturn fmt.Errorf(\"no rows updated, ID %d not found\", data.ID)\n\t}\n\n\t// 正常終了のため、nilを返す\n\treturn nil\n}\n```\n\n## 動作確認\n\nテストコードを実行してグリーンバーになっていることを確認できたらOK",
      "body_updated_at": "2024-10-09"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-09",
      "body_markdown": "# リファクタリング\n\nテストコードでIDを1としてハードコードしてしまっている。\nこれを動的に変更したい。\n\n## 方針\n\n- IDを指定しないinsertの場合に、IDを返すようにする\n- 返されたIDを使用して、データの確認、削除などを行う\n\n## 実装\n\nあちこちいじる必要がある。\nこういった場合はVSCodeのエラー表示をうまく使う。\n\nまず変えたい場所のコードを変更する。\nこの場合はテストコードの以下の箇所を以下のように変える。\n\n```go\n\t// testデータのインサート\n\tlastInsertID, err := db.Insert(testData)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to insert test data: %v\", err)\n\t}\n```\n\nすると赤波線でコンパイル時エラーになる箇所を教えてくれる。\n![](https://storage.googleapis.com/zenn-user-upload/5b8b7dda9c74-20241009.png)\n\nこんな感じ。\n![](https://storage.googleapis.com/zenn-user-upload/156a92ed72eb-20241009.png)\n\nこのエラーをうけて、コードを修正していく。\n\n## Insert関数の修正\n\ndb.go\n\n```go\n/*\nデータをDBにINSERTする\n*/\nfunc Insert(data models.RegisterRequest) (int64, error) {\n\tdb := CreateDBConnection(envVar)\n\tdefer db.Close()\n\n\tresult, err := db.Exec(\"INSERT INTO todos (Content, Until) VALUES (?, ?)\", data.Content, data.Until)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to execute insert: %v\", err)\n\t}\n\n\tlastInsertID, err := result.LastInsertId()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to retrieve last insert ID: %v\", err)\n\t}\n\n\treturn lastInsertID, nil\n}\n```\n\nこれでInsert関数は期待する処理に変更できた。\n\n## Insert関数呼び出し側を変更する。\n\nあとは呼び出し側の処理を変えていく必要があるので、そこを変更していく。\n\nVSCodeのエクスプローラーで真っ赤っ赤になっているのファイルが、エラーが発生しているファイルとなる。\n![](https://storage.googleapis.com/zenn-user-upload/4ac6c1387116-20241009.png)\n\n以上を一つ一つ確認して潰していくと良い。\n\n今回でいうと、\n- Insertの返り値が2つになっているので、1つで処理していた箇所の記載を変更する。\n\n対象のファイルは2つ。\nまずはmain.goから。\n\nmain.go\n\n```go\n/*\nリクエストに含まれるデータをDBに登録するハンドラ\n*/\nfunc registerHandler(w http.ResponseWriter, r *http.Request) {\n\tvar req models.RegisterRequest\n\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// 成功の場合のResponseデータを作成\n\tresponse := models.Response{\n\t\tResult: \"SUCCESS\",\n\t}\n\n\t// DBへの登録処理を行う\n\t_, err := db.Insert(req)\n\t// DB登録処理が失敗なら、エラーメッセージを格納したResponseデータに変更\n\tif err != nil {\n\t\tresponse = models.Response{\n\t\t\tResult: \"Data register error.\",\n\t\t}\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(response)\n\n}\n```\n\n## テストコードの変更\n\n本命であるテストコードの変更を行う。\n\nmain_test.go\n\n```go\n/*\nupdateエンドポイントのテストコード\n*/\nfunc TestUpdateHandler(t *testing.T) {\n\t// deleteテスト用のデータを作成\n\tuntilTime := \"2024-12-31\"\n\tuntilDate, err := time.Parse(\"2006-01-02\", untilTime)\n\terrorpkg.CheckError(err)\n\n\ttestData := models.RegisterRequest{\n\t\tContent: \"todo test content\",\n\t\tUntil:   untilDate,\n\t}\n\n\t// testデータのインサート\n\tlastInsertID, err := db.Insert(testData)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to insert test data: %v\", err)\n\t}\n\n\t// 更新前のデータを取得\n\toriginalTodo := db.SelectById(int(lastInsertID))\n\n\t// update用のリクエストデータを作成\n\treqBody := models.UpdateRequest{\n\t\tID: int(lastInsertID),\n\t}\n\n\tjsonData, err := json.Marshal((reqBody))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to marshal request: %v\", err)\n\t}\n\n\treq, err := http.NewRequest(\"POST\", \"/update\", bytes.NewBuffer(jsonData))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to update request: %v\", err)\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\trr := httptest.NewRecorder()\n\n\thandler := http.HandlerFunc(updateHandler)\n\thandler.ServeHTTP(rr, req)\n\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Errorf(\"Handler returned wrong status code: got %v want %v\", status, http.StatusOK)\n\t}\n\n\tvar resBody models.Response\n\tif err := json.NewDecoder(rr.Body).Decode(&resBody); err != nil {\n\t\tt.Fatalf(\"Failed to decode response: %v\", err)\n\t}\n\n\texpectedMessage := \"SUCCESS\"\n\tif resBody.Result != expectedMessage {\n\t\tt.Errorf(\"Handler returned unexpected body: got %v want %v\", resBody.Result, expectedMessage)\n\t}\n\n\t// 更新が実際に行われたかをDBから確認する\n\tupdatedTodo := db.SelectById(int(lastInsertID))\n\tif updatedTodo.Done == originalTodo.Done {\n\t\tt.Errorf(\"Todo 'Done' field was not updated: got %v, expected different value from %v\", updatedTodo.Done, originalTodo.Done)\n\t}\n\n\t// テストデータ削除用にデータを作成\n\tdeleteId := models.DeleteRequest{\n\t\tID: int(lastInsertID),\n\t}\n\terr = db.Delete(deleteId)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to delete test data: %v\", err)\n\t}\n\n}\n```\n\nあとは動作確認してグリーンバーになるのを見届けたらOK。\n\n## Deleteエンドポイントのテストコードも変更\n\nDeleteエンドポイントのテストコードもIDのハードコーディングしているので、こちらも変更した。\n\nコードなどは煩雑になるので、省略する。\n\n",
      "body_updated_at": "2024-10-09"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-10",
      "body_markdown": "# APIのエンドポイントを変更する\n\nここに来て気づいたが、フロント部をも同じサーバーから配信するのであれば、APIのエンドポイントを変えたほうがいい。\n`/api/endpoint`の形式としたい。\n\nというわけで各種変更していく。\nといっても、main.goとテストコードで呼び出ししている箇所を変えるだけ。\n\nmain.goの変更点のみ示す。\n\n```go\nfunc main() {\n\t// リスト(todo)の一覧を取得するハンドラのバインド\n\thttp.HandleFunc(\"/api/todos\", todosHandler)\n\t// リクエストしたデータを登録するハンドラのバインド\n\thttp.HandleFunc(\"/api/register\", registerHandler)\n\t// リクエストしたデータを削除するハンドラのバインド\n\thttp.HandleFunc(\"/api/delete\", deleteHandler)\n\t// リクエストしたデータを更新するハンドラのバインド\n\thttp.HandleFunc(\"/api/update\", updateHandler)\n\n\t// 画面を返すエンドポイント\n\tfs := http.FileServer(http.Dir(\"./static\"))\n\thttp.Handle(\"/\", fs)\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```\n",
      "body_updated_at": "2024-10-10"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-10",
      "body_markdown": "# フロント処理を追加する\n\nフロントの処理を追加していく。\nAPIとしてエンドポイントを作成してDBとの処理は実装されているので、あとはフロントからフェッチする処理が必要。\n\nなお、fetchするのにPromiseという概念が使われるので、参考文献をぺたり。\n\n参考文献\nhttps://qiita.com/cheez921/items/41b744e4e002b966391a",
      "body_updated_at": "2024-10-10"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-10",
      "body_markdown": "# Todoの一覧表示\n\nTodoの一覧を表示する処理を書く。\n\n例の如く小さく進めていく。\n\n## fetchする処理まで書く\n\nまずはエンドポイントからデータを取得できるかを試す。\n\n```js\nconst apiTodoListEndpoint = \"http://localhost:8080/api/todos\"\n\nfetch(apiTodoListEndpoint)\n    .then(response => {\n        if (!response.ok) {\n            throw new Error(\"Network response was not ok \" + response.statusText)\n        }\n        return response.json()\n    })\n    .then(data => {\n        console.log(data)\n    })\n    .catch(error => {\n        console.error(\"There was a problem with the fetch operation:\", error)\n    })\n```\n\n### 動作確認\n\n動作の確認はブラウザから行う。\n\nまずブラウザを開いて、`http://localhost:8080`にアクセスする。\n\n次に、開発者ツールを開いて、コンソールタブを開く。\n\n参考記事\nhttps://qiita.com/nakamura_s/items/2aa1481a76cf820ea618\n\nアクセスしてコンソールタブを見ると、データが取得できているのが確認できる。\n\n以下の画像は例。\n\n![](https://storage.googleapis.com/zenn-user-upload/e506e3208846-20241010.png)\n\n",
      "body_updated_at": "2024-10-10"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-10",
      "body_markdown": "# 取得したデータをフロントに反映する\n\nデータが取得できるのは確認できたので、それをフロントに反映していく。\n\n## 一覧で表示できるようにする\n\nとりあえずJSONのContentのみを取得して表示してみる。\n\n```js\nconst apiTodoListEndpoint = \"http://localhost:8080/api/todos\"\n\nfetch(apiTodoListEndpoint)\n    .then(response => {\n        if (!response.ok) {\n            throw new Error(\"Network response was not ok \" + response.statusText)\n        }\n        return response.json()\n    })\n    .then(data => {\n        data.forEach(todo => {\n            displayTodo(todo)\n        });\n    })\n    .catch(error => {\n        console.error(\"There was a problem with the fetch operation:\", error)\n    })\n\nfunction displayTodo(todo) {\n    const todoList = document.getElementById(\"todoList\")\n\n    // div要素を作成\n    const todoItem = document.createElement(\"div\")\n    // classとしてtodoItemを追加\n    todoItem.classList.add(\"todoItem\")\n\n    // Contentの表示\n    const contentElement = document.createElement(\"p\")\n    contentElement.textContent = todo.Content\n    todoItem.appendChild(contentElement)\n\n    // /Todoの要素をtodoListに追加\n    todoList.appendChild(todoItem)\n}\n```\n\n![](https://storage.googleapis.com/zenn-user-upload/0c223ff7d7fb-20241010.png)"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-10",
      "body_markdown": "# 要素を追加していく\n\n表示できるのは分かったので、ここから更に要素を追加していく。\n\n## Doneボタンの追加\n\n要素ごとにDoneボタンを追加する。\n\n```js\nfunction displayTodo(todo) {\n    const todoList = document.getElementById(\"todoList\")\n\n    // div要素を作成\n    const todoItem = document.createElement(\"div\")\n    // classとしてtodoItemを追加\n    todoItem.classList.add(\"todoItem\")\n\n    // Contentの表示\n    const contentElement = document.createElement(\"p\")\n    contentElement.textContent = todo.Content\n    todoItem.appendChild(contentElement)\n\n    // Doneボタンを表示\n    const doneButton = document.createElement(\"button\")\n    doneButton.textContent = !todo.Done ? \"終了\" : \"戻す\"\n    doneButton.onclick = function() {\n        // onclickは仮置き\n        // 後ほどAPIへのフェッチ処理に変更する\n        alert(\"Todo is marked as done!\")\n    }\n    todoItem.appendChild(doneButton)\n\n    // /Todoの要素をtodoListに追加\n    todoList.appendChild(todoItem)\n}\n```\n\n![](https://storage.googleapis.com/zenn-user-upload/d6d7865fc2be-20241010.png)\n\n三項演算子という記法を使っている。\n\n参考文献\nhttps://qiita.com/H40831/items/8b5fb7e936e5fcb730ca",
      "body_updated_at": "2024-10-10"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-10",
      "body_markdown": "# デザインを整える\n\nボタンが説明文のしたに来ており、非常に見づらい。\nなので、ちょっとだけデザインを整える。\n\nflex-boxを使って、横に並べるだけのデザイン変更。\n\nまずindex.htmlに、CSSの読み込みを追加する。\n\n```html\n<!DOCTYPE html>\n<html lang=\"ja\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Todo App</title>\n    <script src=\"script.js\" defer></script>\n    <!-- cssの読み込み処理 -->\n    <link rel=\"stylesheet\" href=\"styles.css\">\n</head>\n<body>\n    <h1>Welcome to Todo App!</h1>\n    <div>\n        <input placeholder=\"Input new todo\"/>\n        <button>送信</button>\n    </div>\n    <div id=\"todoList\">\n    </div>\n</body>\n</html>\n```\n\n## CSSを記載する\n\n次に、CSSを記載する。\n\nまずはファイルを作成する。\n\n例はコマンドでの作成だが、GUIを用いて作成しても良い。\n\n```sh\ntouch static/styles.css\n```\n\nそして、CSSを以下のように記載する。\n\n```css\n.todoItem {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 10px;\n    border: 1px solid #ddd;\n    margin-top: 10px;\n}\n\n.todoItem p {\n    margin: 0;\n}\n```\n\n## 動作確認\n\nあとはブラウザをリロードすれば画像の様になるはずである。\n\n![](https://storage.googleapis.com/zenn-user-upload/3583af30378d-20241010.png)",
      "body_updated_at": "2024-10-10"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-10",
      "body_markdown": "# Deleteボタンの設置\n\nDeleteボタンを設置してみる。\nDoneボタンを同じように追加してくだけ。\n\n```js\nfunction displayTodo(todo) {\n    const todoList = document.getElementById(\"todoList\")\n\n    // div要素を作成\n    const todoItem = document.createElement(\"div\")\n    // classとしてtodoItemを追加\n    todoItem.classList.add(\"todoItem\")\n\n    // Contentの表示\n    const contentElement = document.createElement(\"p\")\n    contentElement.textContent = todo.Content\n    todoItem.appendChild(contentElement)\n\n    // Doneボタンを表示\n    const doneButton = document.createElement(\"button\")\n    doneButton.textContent = !todo.Done ? \"終了\" : \"戻す\"\n    doneButton.onclick = function() {\n        // onclickは仮置き\n        // 後ほどAPIへのフェッチ処理に変更する\n        alert(\"Todo is marked as done!\")\n    }\n    todoItem.appendChild(doneButton)\n\n    // Deleteボタンの設置\n    const deleteButton = document.createElement(\"button\")\n    deleteButton.textContent = \"削除\"\n    deleteButton.onclick = function() {\n        // onclickは仮置き\n        alert(\"Click delete button!\")\n    }\n    todoItem.appendChild(deleteButton)\n\n    // /Todoの要素をtodoListに追加\n    todoList.appendChild(todoItem)\n}\n```\n![](https://storage.googleapis.com/zenn-user-upload/2769714d477d-20241010.png)\n\nおや、レイアウトが崩れているな。\n\n## レイアウトを微調整する\n\n崩れたレイアウトを微調整する。\n\n具体的には、Todoの説明文の真横にボタンが来るようにしたい。\n\n```css\n.todoItem {\n    display: flex;\n    align-items: center;\n    padding: 10px;\n    border: 1px solid #ddd;\n    margin-top: 10px;\n}\n\n.todoItem p {\n    margin: 0;\n    margin-right: 20px;\n}\n\n.todoItem button {\n    margin-right: 20px;\n}\n```\n\nこんな感じでどうだろう。\n![](https://storage.googleapis.com/zenn-user-upload/c85a3a6b3546-20241010.png)\n\nいい感じ。"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-15",
      "body_markdown": "# リファクタリング\n\nJavaScriptのdisplayTodo()関数が長くなってきたので、分割できるところを分割しようと思う。\n\n## Doneボタン生成コードの切り出し\n\nDoneボタン生成コードを関数に切り出す。\n\nまず、呼び出し側を以下の様に変更しておく。\nコメントアウトしたところが変更した箇所になる。\nなお、ボタンに表示する文字列をちょっと変えている。\n\nscript.js\n```js\n    // Doneボタンを表示\n    // const doneButton = document.createElement(\"button\")\n    // doneButton.textContent = !todo.Done ? \"タスク完了\" : \"未完了に戻す\"\n    // doneButton.onclick = function() {\n         // onclickは仮置き\n         // 後ほどAPIへのフェッチ処理に変更する\n    //     alert(\"Todo is marked as done!\")\n    // }\n    const doneButton = createDoneButton(todo.Done)\n    todoItem.appendChild(doneButton)\n```\n\n呼び出しの一行にまとまった。\n\nあとは、この関数の実体を別の関数として書き出せばいい\n\n```js\nfunction createDoneButton (isDone) {\n    const doneButton = document.createElement(\"button\")\n    doneButton.textContent = isDone ? \"タスク完了\" : \"未完了に戻す\"\n    doneButton.onclick = function() {\n        // onclickは仮置き\n        // 後ほどAPIへのフェッチ処理に変更する\n        alert(\"Todo is marked as done!\")\n    }\n\n    return doneButton\n}\n```\n\n動作確認は省略するが、ブラウザで変更前と同様に動作すればOK\n\n## Deleteボタン生成コードの切り出し\n\nDeleteボタンについても同様に行おう。\nまず呼び出し側から変更する。\n\n```js\n    // Deleteボタンの設置\n    const deleteButton = createDeleteButton()\n    // const deleteButton = document.createElement(\"button\")\n    // deleteButton.textContent = \"削除\"\n    // deleteButton.onclick = function() {\n    //     alert(\"Click delete button!\")\n    // }\n    todoItem.appendChild(deleteButton)\n```\n\n呼び出す対象の関数を書く。\n\n```js\nfunction createDeleteButton () {\n    const deleteButton = document.createElement(\"button\")\n    deleteButton.textContent = \"削除\"\n    deleteButton.onclick = function() {\n        // onclickは仮置き\n        alert(\"Click delete button!\")\n    }\n    return deleteButton\n}\n```\n\n動作確認は行っているが、ログでは省略。\n\n## 意図\n\nコードを関数に切り出した意図としては\n\n- ボタンを一つのコンポーネントとして捉える事ができる。長いコードの一部としてのボタンではなく、ボタンのコードだけに集中できる。\n- ボタンのonClickにボタンの動きを記載するため、切り出していたほうが変更しやすい。\n\nという感じ。",
      "body_updated_at": "2024-10-15"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-15",
      "body_markdown": "# Deleteボタンの処理を追加する\n\nDeleteボタンを押したときの動作を追加しよう。\n\n必要な機能としては以下のようになる。\n\n- APIサーバーにDeleteをリクエストする必要がある\n- DeleteのリクエストはIDを指定して行う\n- リクエストに使うのデータはJSON\n- APIサーバーからのレスポンスを受けて、削除するかしないかを分岐させる\n- レスポンスが「成功」なら、IDに紐づいているDOM要素を削除する\n- レスポンスが「失敗」やエラーなら、ポップアップして削除が失敗した旨を表示する\n\nさて、一つ一つ実装していこう。\n\n## 作業の選定\n\n以上のように、機能がわかった段階で、「何を実装するのが一番簡単か」というのは自問するといい。\n\n今回の場合でいうと、簡単なところはなんだろうか？\n\nAPIサーバーへのリクエスト？\nいや、難しい。\n\n条件分岐のコード？\nいや、APIサーバーへのリクエストを作らないと書けない。（書けるが、モックなどを作る必要があるので、めんどう）\n\nボタンを押したらDOM要素を削除する？\nうん、これは簡単そうである。\n\nというわけで、「削除ボタンを押したら、idに紐づく要素が削除されるようにする」という処理を書いていく。\n\n## IDに紐づくDOM要素の削除\n\nIDをもらったら削除するボタンを作るので、createDeleteButtonに引数を追加する。\n\nまず呼び出し元を変更。\n```js\n    // Deleteボタンの設置\n    const deleteButton = createDeleteButton(todo.ID)\n    todoItem.appendChild(deleteButton)\n```\n\n次に、関数を変更する。\n\n```js\nfunction createDeleteButton (id) {\n    const deleteButton = document.createElement(\"button\")\n    deleteButton.textContent = \"削除\"\n    deleteButton.onclick = function() {\n        removeTodoItem(id)\n    }\n    return deleteButton\n}\n```\n\nremoveTodoItemという架空の関数の呼び出しに変更している。\nこの関数を呼び出せば、IDに紐づくTodoが削除されるという寸法。\n\nというわけで、その関数の中身を書いていこう。\n\n```js\nfunction removeTodoItem(id) {\n    const todoItem = document.querySelector(`[data-id='${id}']`)\n    if (todoItem) {\n        todoItem.remove()\n    }\n}\n```\n\n## 動作確認\n\n削除ボタンで要素が削除される確認してみよう。\nなお、削除しているだけでDBには反映されてないので、ブラウザでページの更新をしたらタスクは元に戻ることに注意する。\n\n![](https://storage.googleapis.com/zenn-user-upload/07fa25bb04f9-20241015.gif)\n\n## 関数名変更\n\n次の処理を書いていくにあたって、関数名を変更する。\n\n```js\nfunction removeTodoElement(id) {\n    const todoItem = document.querySelector(`[data-id='${id}']`)\n    if (todoItem) {\n        todoItem.remove()\n    }\n}\n```\n\nElementにしたのは、「TodoItemの削除」と「DOM要素としてのTodoItemの削除」を分けたかったから。\n\n呼び出し元も、以下の形に変更する。\n\n```js\nfunction createDeleteButton (id) {\n    const deleteButton = document.createElement(\"button\")\n    deleteButton.textContent = \"削除\"\n    deleteButton.onclick = function() {\n        deleteTodoItem(id)\n    }\n    return deleteButton\n}\n```\n\n## deleteTodoItemの中身を作る\n\nさて、内容を作っていこう。\nまずは、フェッチ処理（APIサーバーへのリクエスト）から。\n\n最初は簡単に、リクエストが成功かどうかにかかわらず、削除する処理を書く。\n\nまず、グローバルな定数として、APIのエンドポイントを定義する。\nscript.jsの頭に書く（ファイルの1行目とか2行目とか）。\n関数内に直接ハードコーディングしない理由は、あとで変更が容易だから。APIのエンドポイントを変更したと思ったときに、ファイルの先頭に書いてあるものを変更したらいいとわかるので。\n\n```js\nconst apiDeleteEndpoint = \"http://localhost:8080/api/delete\"\n```\n\nさて、これを受けて、関数の処理を書こう。\n\n```js\nfunction deleteTodoItem(id) {\n    // リクエストする対象のIDをJSONに詰める\n    const requestData = {\n        ID: id\n    }\n\n    // /api/deleteに対して、リクエストを送る\n    fetch(apiDeleteEndpoint, {\n        method: \"DELETE\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(requestData)\n    })\n    .then(() => {\n        removeTodoElement(id)\n    })\n}\n```\n\nこれで、削除リクエストがAPIに送信されるので、DBのデータが削除されるようになった。\n\n動作確認は省略するが、以下の点を確認すると良いと思う。\n- 削除ボタンを押して、削除されることを確認する。その後、ブラウザを更新し、削除したタスクがちゃんと削除されることを確認する。\n- MySQLクライアントからDBに接続し、削除前のデータを確認したあと、削除ボタンを押して、DBからデータが消えたかどうかを確認する。\n\n\n## レスポンスが成功かどうかで処理を分岐する\n\nあとはレスポンスにより動作を分岐する処理を書けばいい。\n\n```js\nfunction deleteTodoItem(id) {\n    // リクエストする対象のIDをJSONに詰める\n    const requestData = {\n        ID: id\n    }\n\n    // /api/deleteに対して、リクエストを送る\n    fetch(apiDeleteEndpoint, {\n        method: \"DELETE\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(requestData)\n    })\n    .then((response) => {\n        // responseがエラーの場合\n        if (!response.ok) {\n            throw new Error(\"Failed to delete Todo item\")\n        }\n        return response.json()\n    })\n    .then(responseJson => {\n        // responseで返ってきたJSONの内容により処理を分岐\n        // 成功の場合\n        if (responseJson.result === \"SUCCESS\") {\n            removeTodoElement(id)\n        // 失敗の場合\n        } else {\n            alert(`Error: ${responseJson.result}`)\n        }\n    })\n    // フェッチそのもののエラーをキャッチする\n    .catch(error => {\n        console.error(\"There was a problem with the fetch operation:\", error)\n    })\n\n}\n```",
      "body_updated_at": "2024-10-15"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-16",
      "body_markdown": "# APIのドキュメント化\n\nフロント開発を進める前に、APIのドキュメント化を行う。\n\n今の段階では、フロントを開発するときにバックエンドのソースを読みながら行っているので、非常に非効率。\nというかめんどくさい。\n\n## ツールの選定\n\nSwaggerUIを使いたいと思う。\ngo用のライブラリがあったので、それを使用する。\n\nリポジトリ\nhttps://github.com/swaggo/swag\n\n参考記事\nhttps://zenn.dev/toraco/articles/858a9b2fe72508\n\n## インストール\n\nまずはインストールしておく。\n\n```sh\ngo get -u github.com/swaggo/swag/cmd/swag\ngo get -u github.com/swaggo/http-swagger\n```\n\nなお、公式のリポジトリの手順と若干違ってhttp-swaggerがあるのは、Goサーバー上で Swagger UIをホスティングするために使用する。\n\n\n#### インストールの失敗\n\n上記のコマンドでインストールが失敗しているらしい。\nバージョンコマンドで動作確認をしたが、反応が無い。\n\n```sh\nswag --version\nzsh: command not found: swag\n```\n\n色々調べたところ、以下の対処でいいとわかったので、再度インストール。\n\n```sh\ngo install github.com/swaggo/swag/cmd/swag@latest\n```\n\n```sh\n# このコマンドでバイナリインストール先が存在するかを確認する。\ngo env GOPATH\n# ターミナルで移動して、swagが存在するのも確認したので、以下のようのコマンドでパスを設定する\nexport PATH=$PATH:$(go env GOPATH)/bin\n\n# なお、コマンドパスの永続化についても行う。\n# mac環境のため、zshrcに設定する。\nvim ~/.zshrc\n# .zshrcに書き込んで保存すれば完了\n```\n\n上記のコマンドを行った結果、バージョンが確認できるようになったので、インストール成功。\n\n```sh\nswag --version\nswag version v1.16.3\n```\n\n## 試しにUpdate用のハンドラのみをドキュメント化\n\nさて、まずひとつのハンドラから試して動作を確認する。\nまず、updateHandlerメソッドの頭に、swaggo用のドキュメントを記載する。\n\nmain.go\n```go\n// updateHandler godoc\n// @Summary Update a todo\n// @Description Update the status of a todo by ID\n// @Tags todos\n// @Accept json\n// @Produce json\n// @Param updateRequest body models.UpdateRequest true \"Update Todo\"\n// @Success 200 {object} models.Response\n// @Failure 400 {object} models.Response\n// @Failure 500 {object} models.Response\n// @Router /api/update [put]\n/*\nリクエストで指定したIDのデータの状態を更新するハンドラ\n*/\nfunc updateHandler(w http.ResponseWriter, r *http.Request) {\n```\n\n次に、呼び出し側のmain関数に、ドキュメントの記載と、swaggerの確認用のエンドポイントを定義する。\n\nmain.go\n```go\n// @title Go Todo API\n// @version 1.0\n// @description This is a sample Todo API.\n// @host localhost:8080\n// @BasePath /api\nfunc main() {\n\t// swaggerドキュメントの設定\n\thttp.HandleFunc(\"/swagger/\", httpSwagger.WrapHandler)\n\n\t// リスト(todo)の一覧を取得するハンドラのバインド\n\thttp.HandleFunc(\"/api/todos\", todosHandler)\n\t// リクエストしたデータを登録するハンドラのバインド\n\thttp.HandleFunc(\"/api/register\", registerHandler)\n\t// リクエストしたデータを削除するハンドラのバインド\n\thttp.HandleFunc(\"/api/delete\", deleteHandler)\n\t// リクエストしたデータを更新するハンドラのバインド\n\thttp.HandleFunc(\"/api/update\", updateHandler)\n\n\t// 画面を返すエンドポイント\n\tfs := http.FileServer(http.Dir(\"./static\"))\n\thttp.Handle(\"/\", fs)\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```\n\n最後に、インポート文を追加する。\nswaggo用のもの、それから、公開するSwaggerUIのドキュメントのパスを指定する。\n\n```go\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"todoApp/internal/db\"\n\t\"todoApp/internal/models\"\n\n\t_ \"todoApp/docs\"\n\n\t\"github.com/swaggo/http-swagger\"\n)\n```\n\nコマンドラインから以下のコマンドを入力してドキュメントを生成する。\n\n```sh\nswag init\n```\n\nさて、動作確認のためにサーバーを立ち上げ、ブラウザから`http://localhost:8080/swagger/index.html`にアクセスする。\n\n```sh\ngo run main.go\n```\n\n![](https://storage.googleapis.com/zenn-user-upload/a194285bb1d3-20241016.png)\n\n展開するとこんな感じ\n\n![](https://storage.googleapis.com/zenn-user-upload/e66d0c78d0b7-20241016.png)",
      "body_updated_at": "2024-10-16"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-16",
      "body_markdown": "# ドキュメントの変更\n\n日本語の方が読みやすいので、説明文を変更する。\n\n```go\n// @title Go Todo API\n// @version 1.0\n// @description TodoアプリのバックエンドAPIです。\n// @host localhost:8080\n// @BasePath /api\nfunc main() {\n\t// swaggerドキュメントの設定\n\thttp.HandleFunc(\"/swagger/\", httpSwagger.WrapHandler)\n\n\t// リスト(todo)の一覧を取得するハンドラのバインド\n\thttp.HandleFunc(\"/api/todos\", todosHandler)\n\t// リクエストしたデータを登録するハンドラのバインド\n\thttp.HandleFunc(\"/api/register\", registerHandler)\n\t// リクエストしたデータを削除するハンドラのバインド\n\thttp.HandleFunc(\"/api/delete\", deleteHandler)\n\t// リクエストしたデータを更新するハンドラのバインド\n\thttp.HandleFunc(\"/api/update\", updateHandler)\n\n\t// 画面を返すエンドポイント\n\tfs := http.FileServer(http.Dir(\"./static\"))\n\thttp.Handle(\"/\", fs)\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\n// updateHandler godoc\n// @Summary IDに紐づくTodoのDoneを更新する\n// @Description Update the status of a todo by ID\n// @Tags todos\n// @Accept json\n// @Produce json\n// @Param updateRequest body models.UpdateRequest true \"Update Todo\"\n// @Success 200 {object} models.Response\n// @Failure 400 {object} models.Response\n// @Failure 500 {object} models.Response\n// @Router /api/update [put]\n/*\nリクエストで指定したIDのデータの状態を更新するハンドラ\n*/\nfunc updateHandler(w http.ResponseWriter, r *http.Request) {\n// 以下略\n```\n\nビルドのし直しをして、再度アクセスする\n```sh\n# ビルドし直し\nswag init\n```\n\n![](https://storage.googleapis.com/zenn-user-upload/5aed3e500d21-20241016.png)\n\n",
      "body_updated_at": "2024-10-16"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-17",
      "body_markdown": "# 残ったswaggo用のドキュメントを書く\n\n残ったエンドポイントのドキュメントを記載する。\n\nソースコードが長いが、記載が終わったものが以下になる\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"todoApp/internal/db\"\n\t\"todoApp/internal/models\"\n\n\t_ \"todoApp/docs\"\n\n\thttpSwagger \"github.com/swaggo/http-swagger\"\n)\n\n// @title Go Todo API\n// @version 1.0\n// @description TodoアプリのバックエンドAPIです。\n// @host localhost:8080\n// @BasePath /api\nfunc main() {\n\t// swaggerドキュメントの設定\n\thttp.HandleFunc(\"/swagger/\", httpSwagger.WrapHandler)\n\n\t// リスト(todo)の一覧を取得するハンドラのバインド\n\thttp.HandleFunc(\"/api/todos\", todosHandler)\n\t// リクエストしたデータを登録するハンドラのバインド\n\thttp.HandleFunc(\"/api/register\", registerHandler)\n\t// リクエストしたデータを削除するハンドラのバインド\n\thttp.HandleFunc(\"/api/delete\", deleteHandler)\n\t// リクエストしたデータを更新するハンドラのバインド\n\thttp.HandleFunc(\"/api/update\", updateHandler)\n\n\t// 画面を返すエンドポイント\n\tfs := http.FileServer(http.Dir(\"./static\"))\n\thttp.Handle(\"/\", fs)\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\n// updateHandler godoc\n// @Summary IDに紐づくTodoのDoneを更新する\n// @Description IDに紐づいているTodoのステータスを更新する。呼び出す度に、Doneのステータスをトグルする。\n// @Tags todos\n// @Accept json\n// @Produce json\n// @Param updateRequest body models.UpdateRequest true \"Update Todo\"\n// @Success 200 {object} models.Response\n// @Failure 400 {object} models.Response\n// @Failure 500 {object} models.Response\n// @Router /api/update [put]\n/*\nリクエストで指定したIDのデータの状態を更新するハンドラ\n*/\nfunc updateHandler(w http.ResponseWriter, r *http.Request) {\n\tvar req models.UpdateRequest\n\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tresponse := models.Response{\n\t\tResult: \"SUCCESS\",\n\t}\n\n\t// データの更新を行う\n\terr := db.Update(req)\n\n\tif err != nil {\n\t\tresponse = models.Response{\n\t\t\tResult: \"Data update error.\",\n\t\t}\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(response)\n}\n\n// Handler godoc\n// @Summary IDに紐づくTodoを削除する\n// @Description IDに紐づくTodoをDBから削除する\n// @Tags todos\n// @Accept json\n// @Produce json\n// @Param deleteRequest body models.DeleteRequest true \"Delete Todo\"\n// @Success 200 {object} models.Response\n// @Failure 400 {object} models.Response\n// @Failure 500 {object} models.Response\n// @Router /api/delete [delete]\n/*\nリクエストで指定したIDのデータを削除するハンドラ\n*/\nfunc deleteHandler(w http.ResponseWriter, r *http.Request) {\n\tvar req models.DeleteRequest\n\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tresponse := models.Response{\n\t\tResult: \"SUCCESS\",\n\t}\n\n\t// DBの削除処理を行う\n\terr := db.Delete(req)\n\n\tif err != nil {\n\t\tresponse = models.Response{\n\t\t\tResult: \"Data delete error.\",\n\t\t}\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(response)\n}\n\n// registerhandler godoc\n// @Summary TodoをDBに登録する\n// @Description リクエストに含まれるTodoのデータをDBに登録する\n// @Tags todos\n// @Accept json\n// @Produce json\n// @Param registerRequest body models.RegisterRequest true \"Register Todo\"\n// @Success 200 {object} models.Response\n// @Failure 400 {object} models.Response\n// @Failure 500 {object} models.Response\n// @Router /api/register [post]\n/*\nリクエストに含まれるデータをDBに登録するハンドラ\n*/\nfunc registerHandler(w http.ResponseWriter, r *http.Request) {\n\tvar req models.RegisterRequest\n\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// 成功の場合のResponseデータを作成\n\tresponse := models.Response{\n\t\tResult: \"SUCCESS\",\n\t}\n\n\t// DBへの登録処理を行う\n\t_, err := db.Insert(req)\n\t// DB登録処理が失敗なら、エラーメッセージを格納したResponseデータに変更\n\tif err != nil {\n\t\tresponse = models.Response{\n\t\t\tResult: \"Data register error.\",\n\t\t}\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(response)\n\n}\n\n// todosHandler godoc\n// @Summary Todoのリストを取得する\n// @Description DBに登録されているすべてのTodoをリストで取得する\n// @Tags todos\n// @Accept json\n// @Produce json\n// @Success 200 {object} models.Todo\n// @Failure 400 {object} models.Todo\n// @Failure 500 {object} models.Todo\n// @Router /api/todos [get]\n/*\nDBからTodoの全リストを取得して、レスポンスするハンドラ\n*/\nfunc todosHandler(w http.ResponseWriter, r *http.Request) {\n\ttodos := db.SelectAll()\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\terr := json.NewEncoder(w).Encode(todos)\n\tif err != nil {\n\t\thttp.Error(w, \"Filed to encode users\", http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n```\n\n完成したものがこちら\n\n![](https://storage.googleapis.com/zenn-user-upload/8210732ea095-20241017.png)\n\nこれでAPIの仕様が確認しやすくなった。",
      "body_updated_at": "2024-10-17"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-21",
      "body_markdown": "# UPDATE\n\nTodoのDONEボタンを押したときの処理を作る。\n具体的に言うと、「未完了に戻す」となっているボタンの挙動。\n\n![](https://storage.googleapis.com/zenn-user-upload/4121555d13ab-20241021.png)\n\n## 呼び出し側を変更する\n\nまず呼び出し側を変更する。\nPUTリクエストに必要な情報を関数に渡す必要があるので、まずはAPIの仕様から調査。\n\n`http://localhost:8080/swagger/index.html`にブラウザからアクセスし、PUTの仕様を確認。\n\n![](https://storage.googleapis.com/zenn-user-upload/d8f06441cf61-20241021.png)\n\nJSONでidのみをリクエストすることがわかる。\n\nなので、関数にIDを渡し、そのIDを元にPUTリクエストを行うように変更する。\n\nまずは呼び出し側を変更する。\n\n```diff js\n-     // Doneボタンを表示\n-  const doneButton = createDoneButton(todo.Done)\n\n+    // Doneボタンを表示\n+ const doneButton = createDoneButton(todo.ID, todo.Done)\n```\n\n## 関数側を変更する\n\n関数の処理を変更していこう。\n\n必要なことは以下になる。\n\n- deleteと同様に、updateエンドポイントにフェッチを行う\n- フェッチに成功した場合に、ボタン文字列のトグルを行う\n\n要するに、既存のボタン文字列のトグル処理を、フェッチの成功の場合に行う形に変更すればよい。\n\ndeleteのときのコードをコピペしてきて、必要な箇所を変更していく。\n\nまずcreateDoneButtonの方から\n\n```diff js\nfunction createDoneButton (id, isDone) {\n\n    const doneButton = document.createElement(\"button\")\n    doneButton.textContent = isDone ? \"タスク完了\" : \"未完了に戻す\"\n    doneButton.onclick = function() {\n-        // onclickは仮置き\n-      // 後ほどAPIへのフェッチ処理に変更する\n-        alert(\"Todo is marked as done!\")\n+        updateDoneButton(id)\n\n    }\n\n    return doneButton\n}\n```\n\nちょっと仕様を誤解していたので、以下のように記載を変更。\nついでに、再利用が可能なようにテキストは定数として宣言している。\n\n```js\nconst taskDoneButtonText = \"未完了に戻す\"\nconst taskNotDoneButtonText = \"タスク完了\"\n\nfunction createDoneButton (id, isDone) {\n    const doneButton = document.createElement(\"button\")\n    doneButton.textContent = isDone ? taskDoneButtonText : taskNotDoneButtonText\n    doneButton.onclick = function() {\n        updateDoneButton(id)\n    }\n\n    return doneButton\n}\n```\n\nさて、中身となるupdateDoneButtonを実装していく。\n基本的にはdeleteTodoItem関数と同じ。\n成功時に呼び出す関数のみが違う。\n\n```js\nfunction updateDoneButton(id) {\n    // リクエストする対象のIDをJSONに詰める\n    const requestData = {\n        ID: id\n    }\n\n    // /api/deleteに対して、リクエストを送る\n    fetch(apiUpdateEndpoint, {\n        method: \"PUT\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(requestData)\n    })\n    .then((response) => {\n        // responseがエラーの場合\n        if (!response.ok) {\n            throw new Error(\"Failed to update Todo item\")\n        }\n        return response.json()\n    })\n    .then(responseJson => {\n        // responseで返ってきたJSONの内容により処理を分岐\n        // 成功の場合\n        if (responseJson.result === \"SUCCESS\") {\n            toggleUpdateButton(id)\n        // 失敗の場合\n        } else {\n            alert(`Error: ${responseJson.result}`)\n        }\n    })\n    // フェッチそのもののエラーをキャッチする\n    .catch(error => {\n        console.error(\"There was a problem with the fetch operation:\", error)\n    })\n}\n```\n\nさて、成功時に呼び出す関数の内容を実装しよう。\n\n```js\n\nfunction toggleUpdateButton(id) {\n    const todoItem = document.querySelector(`[data-id='${id}']`)\n    if (todoItem) {\n        const doneButton = todoItem.querySelector(\"button\")\n\n        if (doneButton) {\n            if(doneButton.textContent === taskDoneButtonText) {\n                doneButton.textContent = taskNotDoneButtonText\n            } else if (doneButton.textContent === taskNotDoneButtonText) {\n                doneButton.textContent = taskDoneButtonText\n            }\n        }\n    } \n}\n```\n\nトグルしているのが確認できる。\n![](https://storage.googleapis.com/zenn-user-upload/e80c4b7a2b6f-20241021.gif)\n\nDBの値も変更しているのがわかる。（一番上のレコードのDoneカラム）\n![](https://storage.googleapis.com/zenn-user-upload/fcd1d0585a21-20241021.png)\n",
      "body_updated_at": "2024-10-21"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-22",
      "body_markdown": "# POSTを実装する\n\nPOST処理を実装する。\n具体的に言うと、Todoの登録のリクエストを実装する。\n\n## APIのリクエスト仕様を確認\n\nPOSTのリクエスト仕様を確認する。\n![](https://storage.googleapis.com/zenn-user-upload/48c54bbc721a-20241022.png)\n\nuntilは一応用意していたが、実は使わないカラムとなっている。\n\n拡張してもよいが、この段階では使わないので削除する。\n\n## untilの削除\n\nuntilカラムを削除するための変更を行っていく。\n\nやるタスクは以下になる。\n\n- [ ] DBからuntilカラムを削除する\n- [ ] APIの処理からuntilを除く\n\n## DBからuntilカラムを削除する\n\nこれは簡単である。\nカラムの削除をSQLで実行すればいい。\n\nmysqlにログインして、以下のSQL文を実行する。\n\n```sql\nALTER TABLE todos DROP COLUMN until;\n```\n\n```sql\nmysql> DESCRIBE todos;\n+-----------+--------------+------+-----+-------------------+-----------------------------------------------+\n| Field     | Type         | Null | Key | Default           | Extra                                         |\n+-----------+--------------+------+-----+-------------------+-----------------------------------------------+\n| ID        | int          | NO   | PRI | NULL              | auto_increment                                |\n| Content   | varchar(255) | NO   |     | NULL              |                                               |\n| Done      | tinyint(1)   | NO   |     | 0                 |                                               |\n| CreatedAt | datetime     | NO   |     | CURRENT_TIMESTAMP | DEFAULT_GENERATED                             |\n| UpdatedAt | datetime     | NO   |     | CURRENT_TIMESTAMP | DEFAULT_GENERATED on update CURRENT_TIMESTAMP |\n+-----------+--------------+------+-----+-------------------+-----------------------------------------------+\n5 rows in set (0.01 sec)\n```\n\nUntilカラムが削除されているのが確認できる。\n\n## APIの処理からuntilを除く\n\nAPIの方を修正していこう。\n\nまず型定義から削除する。\ntodo.go\n```diff go\ntype RegisterRequest struct {\n\tContent string `db:\"Content\"`\n-\tUntil   time.Time `db:\"Until\"`\n}\n\ntype Todo struct {\n\tID        int       `db:\"ID\"`\n\tContent   string    `db:\"Content\"`\n\tDone      bool      `db:\"Done\"`\n-\tUntil     *time.Time `db:\"Until\"`\n\tCreatedAt time.Time `db:\"CreatedAt\"`\n\tUpdatedAt time.Time `db:\"UpdatedAt\"`\n}\n```\n\n次に上記の2つの構造体に関係する箇所を修正していく。\n\n![](https://storage.googleapis.com/zenn-user-upload/675de4ffa313-20241022.png)\n\nVSCodeを使っていると、赤い色になっているファイルが修正対象なので、わかりやすいと思う。\n\n変更した箇所のみを示す。\n\ndb.go\n```diff go\n/*\nデータをDBにINSERTする\n*/\nfunc Insert(data models.RegisterRequest) (int64, error) {\n\tdb := CreateDBConnection(envVar)\n\tdefer db.Close()\n\n-\tresult, err := db.Exec(\"INSERT INTO todos (Content, Until) VALUES (?, ?)\", data.Content, data.Until)\n+\tresult, err := db.Exec(\"INSERT INTO todos (Content) VALUES (?)\", data.Content)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to execute insert: %v\", err)\n\t}\n\n\tlastInsertID, err := result.LastInsertId()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to retrieve last insert ID: %v\", err)\n\t}\n\n\treturn lastInsertID, nil\n}\n\n/*\n指定したIDのデータをDBにINSERTする\n*/\nfunc InsertById(id int, data models.RegisterRequest) error {\n\tdb := CreateDBConnection(envVar)\n\tdefer db.Close()\n\n-\t_, err := db.Exec(\"INSERT INTO todos (ID, Content, Until) VALUES (?, ?, ?)\", id, data.Content, data.Until)\n+\t_, err := db.Exec(\"INSERT INTO todos (ID, Content) VALUES (?, ?)\", id, data.Content)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to execute insert: %v\", err)\n\t}\n\n\treturn nil\n}\n```\n\nmain_test.goも同様に修正が必要。\nすべて示すと長くなるので、該当箇所のみ示す。\n\n```diff go\n/*\nupdateエンドポイントのテストコード\n*/\nfunc TestUpdateHandler(t *testing.T) {\n\t// deleteテスト用のデータを作成\n-\tuntilTime := \"2024-12-31\"\n-\tuntilDate, err := time.Parse(\"2006-01-02\", untilTime)\n-\terrorpkg.CheckError(err)\n\n\ttestData := models.RegisterRequest{\n\t\tContent: \"todo test content\",\n-\t\tUntil:   untilDate,\n\t}\n\n// 省略\n\n/*\nDeleteエンドポイントのテストコード\n*/\nfunc TestDeleteHandler(t *testing.T) {\n\t// deleteテスト用のデータを作成\n-\tuntilTime := \"2024-12-31\"\n-\tuntilDate, err := time.Parse(\"2006-01-02\", untilTime)\n-\terrorpkg.CheckError(err)\n\n\n\ttestData := models.RegisterRequest{\n\t\tContent: \"todo test content\",\n-\t\tUntil:   untilDate,\n\t}\n\n// 省略\n\n/*\n登録エンドポイントのテスト\n*/\nfunc TestRegisterHandler(t *testing.T) {\n\t// リクエスト用のJSONデータの作成\n-\tuntilTime := \"2024-12-31\"\n-\tuntilDate, err := time.Parse(\"2006-01-02\", untilTime)\n-\terrorpkg.CheckError(err)\n\n\treqBody := models.RegisterRequest{\n\t\tContent: \"todo test content\",\n-\t\tUntil:   untilDate,\n\t}\n```\n\nコードを変更したので、リグレッションテスト。\nテストに書いたコードを実行することで、動きを担保する。\n\n![](https://storage.googleapis.com/zenn-user-upload/6e07ae161abc-20241022.png)\n\n赤枠に示したいずれかのボタンを押すと、ファイル単位でテストできる。\n\n実行したが、何かエラーが出る。\n\n```sh\n2024/10/22 20:49:20 invalid DSN: missing the slash separating the database name\nFAIL    todoApp 0.389s\nFAIL\n```\n\nいろいろ調べた結果、どうやら下に示しているテストコードと、.envに定義している`DATABASE`の環境変数が喧嘩しているらしい。\n\n```go\n\nfunc TestLoadEnv(t *testing.T) {\n\tos.Setenv(\"DATABASE\", \"test-dsn\")\n\tdsn := env.LoadEnv(\"DATABASE\")\n\tassert.Equal(t, \"test-dsn\", dsn, \"環境変数の値が正しく読み込まれていません\")\n}\n```\n\nなので、テストコードの方の環境変数をテスト用に変更する。\n\n```go\nfunc TestLoadEnv(t *testing.T) {\n\tos.Setenv(\"DATABASE_TEST\", \"test-dsn\")\n\tdsn := env.LoadEnv(\"DATABASE_TEST\")\n\tassert.Equal(t, \"test-dsn\", dsn, \"環境変数の値が正しく読み込まれていません\")\n}\n```\n\n無事テストも成功した。\n\n```sh\nok  \ttodoApp\t0.396s\n```\n\n## SwaggerUIへの反映\n\nSwaggerUIへの反映も忘れずに行う。\n\n```sh\nswag init\n```\n\n![](https://storage.googleapis.com/zenn-user-upload/b669aac8fb77-20241022.png)",
      "body_updated_at": "2024-10-22"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-22",
      "body_markdown": "# POSTを実装する2\n\n長くなってきたので、コメントを分ける。\n\ninputから入力したタスクを登録する処理を書いていく。\n\nまず、JavaScriptから見つけることができるように、input要素とbutton要素にidを追加する。\n\n```html\n<!DOCTYPE html>\n<html lang=\"ja\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Todo App</title>\n    <script src=\"script.js\" defer></script>\n    <link rel=\"stylesheet\" href=\"styles.css\">\n</head>\n<body>\n    <h1>Welcome to Todo App!</h1>\n    <div>\n        <input id=\"createInput\" placeholder=\"Input new todo\"/>\n        <button id=\"createButton\">送信</button>\n    </div>\n    <div id=\"todoList\">\n    </div>\n</body>\n</html>\n```\n\n一旦、簡単なコードを書いて、buttonに要素が追加できるかを確認する\n\n```js\ndocument.getElementById(\"createButton\").addEventListener(\"click\", function() {\n    alert(\"Button clicked!\");\n});\n```\n\nイベントリスナーという機能を使っているので、参考\n\nhttps://qiita.com/mzmz__02/items/873118fbd8723c44956d\n\n",
      "body_updated_at": "2024-10-22"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-22",
      "body_markdown": "## POSTを実装する3\n\n作業の関係からコメントをさらに分割\n\n## 機能を実装していく\n\nさて、これでボタンに関数を結びつけることができたので、実際に使用する関数を書いていく。\n\nTodoは以下になる。(順番は思いつき順なので、実装順ではない。要するにテキトー）\n\n- [ ] APIにPOSTをフェッチするコードを書く\n- [ ] フェッチが成功したら、POSTしたTodoを画面に追加する（末尾に追加する）\n- [ ] POSTが成功した場合のAPIを変更する(追加のために、Todoのデータを返すようにした方が良い)\n- [ ] テストコードの変更（API側の処理を新規登録したTodoを返すように変更するので）\n\n## テストコードの変更\n\nまず、POSTしたあとに、画面に新規登録されたTodoを追加しなければならない。\n現在は画像のように、stringが入ったresultだけが返ってくる形式になっている。\n![](https://storage.googleapis.com/zenn-user-upload/ce9180a56ec8-20241023.png)\n\nレスポンスではTodo型として登録されたTodoを返し、そのデータを用いて画面に反映するという流れでやりたい。\n\n要するにこうしたい。\n![](https://storage.googleapis.com/zenn-user-upload/b7901235db0b-20241023.png)\n\nなので、APIコードの変更が必要となる。\n\nというわけで、テストコードから変えていこう。\n\nmain_test.go\n\n```diff go\n/*\n登録エンドポイントのテスト\n*/\nfunc TestRegisterHandler(t *testing.T) {\n\t// リクエスト用のJSONデータの作成\n\treqBody := models.RegisterRequest{\n\t\tContent: \"todo test content\",\n\t}\n\n\tjsonData, err := json.Marshal(reqBody)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to marshal request: %v\", err)\n\t}\n\n\t// JSONリクエストの作成\n\treq, err := http.NewRequest(\"POST\", \"/api/register\", bytes.NewBuffer(jsonData))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create request: %v\", err)\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\t// レスポンス記録のためのレコーダーを用意\n\trr := httptest.NewRecorder()\n\n\t// ハンドラーの呼び出し\n\thandler := http.HandlerFunc(registerHandler)\n\thandler.ServeHTTP(rr, req)\n\n\t// ステータスコードが200かの確認\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Errorf(\"Handler returned wrong status code: got %v want %v\", status, http.StatusOK)\n\t}\n\n\t// レスポンスの内容を確認\n-\tvar resBody models.Response\n+\tvar resBody models.Todo\n\tif err := json.NewDecoder(rr.Body).Decode(&resBody); err != nil {\n\t\tt.Fatalf(\"Failed to decode response: %v\", err)\n\t}\n\n-\texpectedMessage := \"SUCCESS\"\n+\texpectedMessage := \"todo test content\"\n\tif resBody.Result != expectedMessage {\n-\t\tt.Errorf(\"Handler returned unexpected body: got %v want %v\", resBody.Result, expectedMessage)\n+\t\tt.Errorf(\"Handler returned unexpected body: got %v want %v\", resBody.Content, expectedMessage)\n\t}\n}\n```\n\nさて、テストを実行して、レッドバーにしておく。\n![](https://storage.googleapis.com/zenn-user-upload/77de5b64a663-20241023.png)\n\n## APIの修正\n\n登録したTodoをレスポンスできるようにAPI側のコードを修正する。\n\nSwaggerUI用のコメントも修正しておく。\n\nmain.go\n```go\n// registerhandler godoc\n// @Summary TodoをDBに登録する\n// @Description リクエストに含まれるTodoのデータをDBに登録する\n// @Tags todos\n// @Accept json\n// @Produce json\n// @Param registerRequest body models.RegisterRequest true \"Register Todo\"\n// @Success 200 {object} models.Todo\n// @Failure 400 {object} models.Todo\n// @Failure 500 {object} models.Todo\n// @Router /api/register [post]\n/*\nリクエストに含まれるデータをDBに登録するハンドラ\n*/\nfunc registerHandler(w http.ResponseWriter, r *http.Request) {\n\tvar req models.RegisterRequest\n\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// DBへの登録処理を行う\n\tinsertId, err := db.Insert(req)\n\t// DB登録処理が失敗なら、エラーメッセージを格納したResponseデータに変更\n\tif err != nil {\n\t\terrResponse := models.Response{\n\t\t\tResult: \"Data register error.\",\n\t\t}\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tjson.NewEncoder(w).Encode(errResponse)\n\t\treturn\n\t}\n\n\t// 登録成功時のレスポンス\n\tresponse := db.SelectById(int(insertId))\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(response)\n}\n```\n\nさて、これでテストコードを動かして、ちゃんと動くことを確認できたらOK。\n",
      "body_updated_at": "2024-10-23"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-23",
      "body_markdown": "# POSTを実装する4\n\nこれで、APIとしてTodoを返すようになったので、あとはフロント側でフェッチする処理を書くだけである。\n\n布石としておいていた以下のコードを改造して機能を追加していく。\n\n```js\ndocument.getElementById(\"createButton\").addEventListener(\"click\", function() {\n    // ここにフェッチ処理を書く\n    alert(\"Button clicked!\");\n});\n```\n\n## 仮実装\n\nフェッチ動作のみを仮実装する。\n\n```js\nconst apiRegisterEndpoint = \"http://localhost:8080/api/register\"\n\ndocument.getElementById(\"createButton\").addEventListener(\"click\", function() {\n    // inputの値を取得\n    const inputText = document.getElementById(\"createInput\").value\n\n    // 入力が空の場合は何もしない\n    if (!inputText) {\n        alert(\"入力が空です\")\n        return\n    }\n\n    // リクエストする対象のテキストをJSONに詰める\n    const requestData = {\n        Content: inputText\n    }\n\n    fetch(apiRegisterEndpoint, {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(requestData)\n    })\n    .then((response) => {\n        // responseがエラーの場合\n        if (!response.ok) {\n            throw new Error(\"Failed to register Todo item\")\n        }\n        return response.json()\n    })\n    .then(responseJson => {\n        // responseで返ってきたJSONの内容により処理を分岐\n        // 成功の場合\n        if (!responseJson.result) {\n            // todo:ここを変更する\n            alert(\"登録成功!\")\n        // 失敗の場合\n        } else {\n            alert(`Error: ${responseJson.result}`)\n        }\n    })\n    // フェッチそのもののエラーをキャッチする\n    .catch(error => {\n        console.error(\"There was a problem with the fetch operation:\", error)\n    })\n})\n```\n\nコメントにtodo:と書いてあるところに、登録したTodoを、画面の末尾に追加する処理を書く想定。\n一旦、仮実装でフェッチ動作のみ追加している。\n\n![](https://storage.googleapis.com/zenn-user-upload/86df9b6ad6f0-20241023.png)\n\n動作の確認もOK。",
      "body_updated_at": "2024-10-23"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-23",
      "body_markdown": "# POSTのレスポンスのフロントへの反映\n\nPOSTの登録結果をフロント側に反映する。\n\n```js\ndocument.getElementById(\"createButton\").addEventListener(\"click\", function() {\n    // inputの値を取得\n    const inputText = document.getElementById(\"createInput\").value\n\n    // 入力が空の場合は何もしない\n    if (!inputText) {\n        alert(\"入力が空です\")\n        return\n    }\n\n    // リクエストする対象のテキストをJSONに詰める\n    const requestData = {\n        Content: inputText\n    }\n\n    fetch(apiRegisterEndpoint, {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(requestData)\n    })\n    .then((response) => {\n        // responseがエラーの場合\n        if (!response.ok) {\n            throw new Error(\"Failed to register Todo item\")\n        }\n        return response.json()\n    })\n    .then(responseJson => {\n        // responseで返ってきたJSONの内容により処理を分岐\n        // 成功の場合\n        if (!responseJson.result) {\n            displayTodo(responseJson)\n            document.getElementById(\"createInput\").value = \"\"\n        // 失敗の場合\n        } else {\n            alert(`Error: ${responseJson.result}`)\n        }\n    })\n    // フェッチそのもののエラーをキャッチする\n    .catch(error => {\n        console.error(\"There was a problem with the fetch operation:\", error)\n    })\n})\n```\n\nすでに作っていたdisplayTodoにわたすだけで追加できる。\n\nさて、動作確認。\n![](https://storage.googleapis.com/zenn-user-upload/c28caca2e973-20241023.gif)\n\nOK。\n"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-23",
      "body_markdown": "\n# 実装の抜けを修正\n\n実装に抜けがあったのが発覚。\n\n具体的には、PUTでDoneが更新されたときにフロントに反映するのを忘れていた。\n\n取り消し線をトグルする処理を追加した。\n\n```js\nfunction toggleUpdateButton(id) {\n    const todoItem = document.querySelector(`[data-id='${id}']`)\n    if (todoItem) {\n        const doneButton = todoItem.querySelector(\"button\")\n        const contentElement = todoItem.querySelector(\"p\")\n\n        if (doneButton) {\n            if(doneButton.textContent === taskDoneButtonText) {\n                doneButton.textContent = taskNotDoneButtonText\n                contentElement.style.textDecoration = \"none\"\n            } else if (doneButton.textContent === taskNotDoneButtonText) {\n                doneButton.textContent = taskDoneButtonText\n                contentElement.style.textDecoration = \"line-through\"\n            }\n        }\n    } \n}\n```\n\n取り消し線が確認できる。\n![](https://storage.googleapis.com/zenn-user-upload/f4de1d1fd9a2-20241023.gif)",
      "body_updated_at": "2024-10-23"
    },
    {
      "author": "kip2",
      "created_at": "2024-10-23",
      "body_markdown": "# 完成\n\n完成したので、無事クローズ。\n\n最後にリポジトリのURLをぺたり。\n\nhttps://github.com/kip2/todo-app-go"
    }
  ]
}